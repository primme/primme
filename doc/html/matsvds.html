

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>MATLAB Interface &mdash; PRIMME 3.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Parameter Description" href="appendixsvds.html" />
    <link rel="prev" title="Python Interface" href="pysvds.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
          

          
            <a href="readme.html">
          

          
            
            <img src="_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">PRIMME: PReconditioned Iterative MultiMethod Eigensolver</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro.html#support">Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="apieigs.html">Eigenvalue Problems</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="apisvds.html">Singular Value Problems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="svdsc.html">C Library Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="svdsf77.html">FORTRAN Library Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="svdsf90.html">FORTRAN 90 Library Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="pysvds.html">Python Interface</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">MATLAB Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="appendixsvds.html">Parameter Description</a></li>
<li class="toctree-l2"><a class="reference internal" href="appendixsvds.html#preset-methods">Preset Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="appendixsvds.html#error-codes">Error Codes</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="readme.html">PRIMME</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="readme.html">Docs</a> &raquo;</li>
        
          <li><a href="apisvds.html">Singular Value Problems</a> &raquo;</li>
        
      <li>MATLAB Interface</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/matsvds.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="appendixsvds.html" class="btn btn-neutral float-right" title="Parameter Description" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pysvds.html" class="btn btn-neutral float-left" title="Python Interface" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="matlab-interface">
<h1>MATLAB Interface<a class="headerlink" href="#matlab-interface" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt>
<code class="sig-name descname">function [varargout] = primme_svds(varargin)</code></dt>
<dd><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">primme_svds()</span></code> finds a few singular values and vectors of a matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>
by calling <a class="reference external" href="https://github.com/primme/primme">PRIMME</a>. <code class="docutils literal notranslate"><span class="pre">A</span></code> is typically large and sparse.</p>
<p><code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(A)</span></code> returns a vector with the 6 largest singular values of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(AFUN,M,N)</span></code> accepts the function handle <code class="docutils literal notranslate"><span class="pre">AFUN</span></code> to perform
the matrix vector products with an M-by-N matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>.
<code class="docutils literal notranslate"><span class="pre">AFUN(X,'notransp')</span></code> returns <code class="docutils literal notranslate"><span class="pre">A*X</span></code> while <code class="docutils literal notranslate"><span class="pre">AFUN(X,'transp')</span></code> returns <code class="docutils literal notranslate"><span class="pre">A’*X</span></code>.
In all the following, <code class="docutils literal notranslate"><span class="pre">A</span></code> can be replaced by <code class="docutils literal notranslate"><span class="pre">AFUN,M,N</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(A,k)</span></code> computes the <code class="docutils literal notranslate"><span class="pre">k</span></code> largest singular values of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(A,k,sigma)</span></code> computes the <code class="docutils literal notranslate"><span class="pre">k</span></code> singular values closest to the
scalar shift <code class="docutils literal notranslate"><span class="pre">sigma</span></code>.</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">sigma</span></code> is a vector, find the singular value <code class="docutils literal notranslate"><span class="pre">S(i)</span></code> closest to each <code class="docutils literal notranslate"><span class="pre">sigma(i)</span></code>, for <code class="docutils literal notranslate"><span class="pre">i&lt;=k</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">sigma</span></code> is <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, it computes the largest singular values.</p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">sigma</span></code> is <code class="docutils literal notranslate"><span class="pre">'S'</span></code>, it computes the smallest singular values.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(A,k,sigma,OPTIONS)</span></code> specifies extra solver parameters.
Some default values are indicated in brackets {}:</p>
<blockquote>
<div><ul>
<li><p><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.aNorm" title="primme_svds_params.aNorm"><code class="xref c c-member docutils literal notranslate"><span class="pre">aNorm</span></code></a>:    estimation of the 2-norm of <code class="docutils literal notranslate"><span class="pre">A</span></code> {0.0 (estimate the norm internally)}</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tol</span></code>:     convergence tolerance <code class="docutils literal notranslate"><span class="pre">NORM([A*V-U*S;A'*U-V*S])</span> <span class="pre">&lt;=</span> <span class="pre">tol</span> <span class="pre">*</span> <span class="pre">NORM(A)</span></code> (see <a class="reference internal" href="appendixsvds.html#c.primme_svds_params.eps" title="primme_svds_params.eps"><code class="xref c c-member docutils literal notranslate"><span class="pre">eps</span></code></a>) { <code class="docutils literal notranslate"><span class="pre">1e-10</span></code> for double precision and <code class="docutils literal notranslate"><span class="pre">1e-3</span></code> for single precision}</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maxit</span></code>:   maximum number of matvecs with <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">A'</span></code> (see <a class="reference internal" href="appendixsvds.html#c.primme_svds_params.maxMatvecs" title="primme_svds_params.maxMatvecs"><code class="xref c c-member docutils literal notranslate"><span class="pre">maxMatvecs</span></code></a>)  {inf}</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>:       maximum basis size (see <a class="reference internal" href="appendixsvds.html#c.primme_svds_params.maxBasisSize" title="primme_svds_params.maxBasisSize"><code class="xref c c-member docutils literal notranslate"><span class="pre">maxBasisSize</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">disp</span></code>:    level of reporting 0-3 (see HIST) {0: no output}</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isreal</span></code>:  if 0, the matrix is complex; else it’s real {0: complex}</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isdouble</span></code>: if 0, the matrix is single; else it’s double {1: double}</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">method</span></code>:  which equivalent eigenproblem to solve</p>
<blockquote>
<div><ul class="simple">
<li><p>‘<a class="reference internal" href="appendixsvds.html#c.primme_svds_preset_method.primme_svds_normalequations" title="primme_svds_preset_method.primme_svds_normalequations"><code class="xref c c-member docutils literal notranslate"><span class="pre">primme_svds_normalequations</span></code></a>’: <code class="docutils literal notranslate"><span class="pre">A'*A</span></code> or <code class="docutils literal notranslate"><span class="pre">A*A'</span></code></p></li>
<li><p>‘<a class="reference internal" href="appendixsvds.html#c.primme_svds_preset_method.primme_svds_augmented" title="primme_svds_preset_method.primme_svds_augmented"><code class="xref c c-member docutils literal notranslate"><span class="pre">primme_svds_augmented</span></code></a>’: <code class="docutils literal notranslate"><span class="pre">[0</span> <span class="pre">A';A</span> <span class="pre">0]</span></code></p></li>
<li><p>‘<a class="reference internal" href="appendixsvds.html#c.primme_svds_preset_method.primme_svds_hybrid" title="primme_svds_preset_method.primme_svds_hybrid"><code class="xref c c-member docutils literal notranslate"><span class="pre">primme_svds_hybrid</span></code></a>’: first normal equations and then augmented (default)</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">u0</span></code>:       initial guesses to the left singular vectors (see <a class="reference internal" href="appendixsvds.html#c.primme_svds_params.initSize" title="primme_svds_params.initSize"><code class="xref c c-member docutils literal notranslate"><span class="pre">initSize</span></code></a>) {[]}</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">v0</span></code>:       initial guesses to the right singular vectors {[]}</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">orthoConst</span></code>: external orthogonalization constraints (see <a class="reference internal" href="appendixsvds.html#c.primme_svds_params.numOrthoConst" title="primme_svds_params.numOrthoConst"><code class="xref c c-member docutils literal notranslate"><span class="pre">numOrthoConst</span></code></a>) {[]}</p></li>
<li><p><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.locking" title="primme_svds_params.locking"><code class="xref c c-member docutils literal notranslate"><span class="pre">locking</span></code></a>:  1, hard locking; 0, soft locking</p></li>
<li><p><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.maxBlockSize" title="primme_svds_params.maxBlockSize"><code class="xref c c-member docutils literal notranslate"><span class="pre">maxBlockSize</span></code></a>: maximum block size</p></li>
<li><p><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.iseed" title="primme_svds_params.iseed"><code class="xref c c-member docutils literal notranslate"><span class="pre">iseed</span></code></a>:    random seed</p></li>
<li><p><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.primme" title="primme_svds_params.primme"><code class="xref c c-member docutils literal notranslate"><span class="pre">primme</span></code></a>:   options for first stage solver</p></li>
<li><p><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.primmeStage2" title="primme_svds_params.primmeStage2"><code class="xref c c-member docutils literal notranslate"><span class="pre">primmeStage2</span></code></a>: options for second stage solver</p></li>
<li><p><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.convTestFun" title="primme_svds_params.convTestFun"><code class="xref c c-member docutils literal notranslate"><span class="pre">convTestFun</span></code></a>: function handler with an alternative convergence criterion.
If <code class="docutils literal notranslate"><span class="pre">FUN(SVAL,LSVEC,RSVEC,RNORM)</span></code> returns a nonzero
value, the triplet <code class="docutils literal notranslate"><span class="pre">(SVAL,LSVEC,RSVEC)</span></code> with residual norm <code class="docutils literal notranslate"><span class="pre">RNORM</span></code>
is considered converged.</p></li>
</ul>
</div></blockquote>
<p>The available options for <code class="docutils literal notranslate"><span class="pre">OPTIONS.primme</span></code> and <code class="docutils literal notranslate"><span class="pre">primmeStage2</span></code> are
the same as <code class="xref mat mat-func docutils literal notranslate"><span class="pre">primme_eigs()</span></code>, plus the option <code class="docutils literal notranslate"><span class="pre">'method'</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(A,k,sigma,OPTIONS,P)</span></code> applies a preconditioner <code class="docutils literal notranslate"><span class="pre">P</span></code> as follows:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">P</span></code> is a matrix it applies <code class="docutils literal notranslate"><span class="pre">P\X</span></code> and <code class="docutils literal notranslate"><span class="pre">P'\X</span></code> to approximate <code class="docutils literal notranslate"><span class="pre">A\X</span></code> and <code class="docutils literal notranslate"><span class="pre">A'\X</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">P</span></code> is a function handle, <code class="docutils literal notranslate"><span class="pre">PFUN</span></code>, <code class="docutils literal notranslate"><span class="pre">PFUN(X,'notransp')</span></code> returns <code class="docutils literal notranslate"><span class="pre">P\X</span></code> and
<code class="docutils literal notranslate"><span class="pre">PFUN(X,'transp')</span></code> returns <code class="docutils literal notranslate"><span class="pre">P’\X</span></code>, approximating <code class="docutils literal notranslate"><span class="pre">A\X</span></code> and <code class="docutils literal notranslate"><span class="pre">A'\X</span></code> respectively.</p></li>
<li><dl class="simple">
<dt>If <code class="docutils literal notranslate"><span class="pre">P</span></code> is a <code class="docutils literal notranslate"><span class="pre">struct</span></code>, it can have one or more of the following fields:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">P.AHA\X</span></code> or <code class="docutils literal notranslate"><span class="pre">P.AHA(X)</span></code> returns an approximation of <code class="docutils literal notranslate"><span class="pre">(A'*A)\X</span></code>,
<code class="docutils literal notranslate"><span class="pre">P.AAH\X</span></code> or <code class="docutils literal notranslate"><span class="pre">P.AAH(X)</span></code> returns an approximation of <code class="docutils literal notranslate"><span class="pre">(A*A')\X</span></code>,
<code class="docutils literal notranslate"><span class="pre">P.aug\X</span></code> or <code class="docutils literal notranslate"><span class="pre">P.aug(X)</span></code> returns an approximation of <code class="docutils literal notranslate"><span class="pre">[zeros(N,N)</span> <span class="pre">A';A</span> <span class="pre">zeros(M,M)]\X</span></code>.</p>
</dd>
</dl>
</li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">P</span></code> is <code class="docutils literal notranslate"><span class="pre">[]</span></code> then no preconditioner is applied.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(A,k,sigma,OPTIONS,P1,P2</span></code>) applies a factorized preconditioner:</p>
<blockquote>
<div><ul class="simple">
<li><p>If both <code class="docutils literal notranslate"><span class="pre">P1</span></code> and <code class="docutils literal notranslate"><span class="pre">P2</span></code> are nonempty, apply <code class="docutils literal notranslate"><span class="pre">(P1*P2)\X</span></code> to approximate <code class="docutils literal notranslate"><span class="pre">A\X</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">P1</span></code> is <code class="docutils literal notranslate"><span class="pre">[]</span></code> and <code class="docutils literal notranslate"><span class="pre">P2</span></code> is nonempty, then <code class="docutils literal notranslate"><span class="pre">(P2'*P2)\X</span></code> approximates <code class="docutils literal notranslate"><span class="pre">A'*A</span></code>.
<code class="docutils literal notranslate"><span class="pre">P2</span></code> can be the R factor of an (incomplete) QR factorization of <code class="docutils literal notranslate"><span class="pre">A</span></code> or
the L factor of an (incomplete) LL’ factorization of <code class="docutils literal notranslate"><span class="pre">A'*A</span></code> (RIF).</p></li>
<li><p>If both <code class="docutils literal notranslate"><span class="pre">P1</span></code> and <code class="docutils literal notranslate"><span class="pre">P2</span></code> are <code class="docutils literal notranslate"><span class="pre">[]</span></code> then no preconditioner is applied.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">[U,S,V]</span> <span class="pre">=</span> <span class="pre">primme_svds(...)</span></code> returns also the corresponding singular vectors.
If <code class="docutils literal notranslate"><span class="pre">A</span></code> is M-by-N and <code class="docutils literal notranslate"><span class="pre">k</span></code> singular triplets are computed, then <code class="docutils literal notranslate"><span class="pre">U</span></code> is M-by-k
with orthonormal columns, <code class="docutils literal notranslate"><span class="pre">S</span></code> is k-by-k diagonal, and <code class="docutils literal notranslate"><span class="pre">V</span></code> is N-by-k with
orthonormal columns.</p>
<p><code class="docutils literal notranslate"><span class="pre">[S,R]</span> <span class="pre">=</span> <span class="pre">primme_svds(...)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">[U,S,V,R]</span> <span class="pre">=</span> <span class="pre">primme_svds(...)</span></code> returns the residual norm
of each <code class="docutils literal notranslate"><span class="pre">k</span></code> triplet, <code class="docutils literal notranslate"><span class="pre">NORM([A*V(:,i)-S(i,i)*U(:,i);</span> <span class="pre">A'*U(:,i)-S(i,i)*V(:,i)])</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">[U,S,V,R,STATS]</span> <span class="pre">=</span> <span class="pre">primme_svds(...)</span></code> returns how many times <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">P</span></code> were
used and elapsed time. The application of <code class="docutils literal notranslate"><span class="pre">A</span></code> is counted independently from
the application of <code class="docutils literal notranslate"><span class="pre">A'</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">[U,S,V,R,STATS,HIST]</span> <span class="pre">=</span> <span class="pre">primme_svds(...)</span></code> returns the convergence history,
instead of printing it. Every row is a record, and the columns report:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">HIST(:,1)</span></code>: number of matvecs</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HIST(:,2)</span></code>: time</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HIST(:,3)</span></code>: number of converged/locked triplets</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HIST(:,4)</span></code>: stage</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HIST(:,5)</span></code>: block index</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HIST(:,6)</span></code>: approximate singular value</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HIST(:,7)</span></code>: residual norm</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HIST(:,8)</span></code>: QMR residual norm</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">OPTS.disp</span></code> controls the granularity of the record. If <code class="docutils literal notranslate"><span class="pre">OPTS.disp</span> <span class="pre">==</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">HIST</span></code>
has one row per converged triplet and only the first four columns are
reported; if <code class="docutils literal notranslate"><span class="pre">OPTS.disp</span> <span class="pre">==</span> <span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">HIST</span></code> has one row per outer iteration and only
the first seven columns are reported; and otherwise <code class="docutils literal notranslate"><span class="pre">HIST</span></code> has one row per QMR
iteration and all columns are reported.</p>
<p>Examples:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="p">=</span> <span class="nb">diag</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">50</span><span class="p">);</span> <span class="n">A</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c">% rectangular matrix of size 200x50</span>

<span class="n">s</span> <span class="p">=</span> <span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="c">% the 10 largest singular values</span>

<span class="n">s</span> <span class="p">=</span> <span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="s">&#39;S&#39;</span><span class="p">)</span> <span class="c">% the 10 smallest singular values</span>

<span class="n">s</span> <span class="p">=</span> <span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">25</span><span class="p">)</span> <span class="c">% the 10 closest singular values to 25</span>

<span class="n">opts</span> <span class="p">=</span> <span class="n">struct</span><span class="p">();</span>
<span class="n">opts</span><span class="p">.</span><span class="n">tol</span> <span class="p">=</span> <span class="mf">1e-4</span><span class="p">;</span> <span class="c">% set tolerance</span>
<span class="n">opts</span><span class="p">.</span><span class="n">method</span> <span class="p">=</span> <span class="s">&#39;primme_svds_normalequations&#39;</span> <span class="c">% set svd solver method</span>
<span class="n">opts</span><span class="p">.</span><span class="n">primme</span><span class="p">.</span><span class="n">method</span> <span class="p">=</span> <span class="s">&#39;DEFAULT_MIN_TIME&#39;</span> <span class="c">% set first stage eigensolver method</span>
<span class="n">opts</span><span class="p">.</span><span class="n">primme</span><span class="p">.</span><span class="n">maxBlockSize</span> <span class="p">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c">% set block size for first stage</span>
<span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">v</span><span class="p">]</span> <span class="p">=</span> <span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="s">&#39;S&#39;</span><span class="p">,</span><span class="n">opts</span><span class="p">);</span> <span class="c">% find 10 smallest svd triplets</span>

<span class="n">opts</span><span class="p">.</span><span class="n">orthoConst</span> <span class="p">=</span> <span class="p">{</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">};</span>
<span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">rnorms</span><span class="p">]</span> <span class="p">=</span> <span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="s">&#39;S&#39;</span><span class="p">,</span><span class="n">opts</span><span class="p">)</span> <span class="c">% find another 10</span>

<span class="c">% Compute the 5 smallest singular values of a rectangular matrix using</span>
<span class="c">% Jacobi preconditioner on (A&#39;*A)</span>
<span class="n">A</span> <span class="p">=</span> <span class="n">sparse</span><span class="p">(</span><span class="nb">diag</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">50</span><span class="p">)</span> <span class="o">+</span> <span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="mi">49</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">));</span>
<span class="n">A</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">50</span><span class="p">)</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c">% size(A)=[200 50]</span>
<span class="n">P</span> <span class="p">=</span> <span class="nb">diag</span><span class="p">(</span><span class="n">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">));</span>
<span class="n">precond</span><span class="p">.</span><span class="n">AHA</span> <span class="p">=</span> <span class="p">@(</span><span class="n">x</span><span class="p">)</span><span class="n">P</span><span class="o">\</span><span class="n">x</span><span class="p">;</span>
<span class="n">s</span> <span class="p">=</span> <span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="s">&#39;S&#39;</span><span class="p">,[],</span><span class="n">precond</span><span class="p">)</span> <span class="c">% find the 5 smallest values</span>

<span class="c">% Estimation of the smallest singular value</span>
<span class="n">A</span> <span class="p">=</span> <span class="nb">diag</span><span class="p">([</span><span class="mi">1</span> <span class="nb">repmat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span> <span class="mi">3</span><span class="p">:</span><span class="mi">100</span><span class="p">]);</span>
<span class="p">[</span><span class="o">~</span><span class="p">,</span><span class="n">sval</span><span class="p">,</span><span class="o">~</span><span class="p">,</span><span class="n">rnorm</span><span class="p">]</span> <span class="p">=</span> <span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;S&#39;</span><span class="p">,</span><span class="n">struct</span><span class="p">(</span><span class="s">&#39;convTestFun&#39;</span><span class="p">,@(</span><span class="n">s</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="n">r</span><span class="o">&lt;</span><span class="n">s</span><span class="o">*</span><span class="mf">.1</span><span class="p">));</span>
<span class="n">sval</span> <span class="o">-</span> <span class="n">rnorm</span> <span class="c">% approximate smallest singular value</span>
</pre></div>
</div>
<p>See also: <a class="reference external" href="https://www.mathworks.com/help/matlab/ref/svds.html">MATLAB svds</a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">primme_eigs()</span></code></p>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="appendixsvds.html" class="btn btn-neutral float-right" title="Parameter Description" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pysvds.html" class="btn btn-neutral float-left" title="Python Interface" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, College of William &amp; Mary

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>