# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
Find a few eigenvalues and eigenvectors, and also singular triplets of a matrix.
Uses PRIMME: https://github.com/primme/primme

"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Primme')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Primme')
    _Primme = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Primme', [dirname(__file__)])
        except ImportError:
            import _Primme
            return _Primme
        try:
            _mod = imp.load_module('_Primme', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Primme = swig_import_helper()
    del swig_import_helper
else:
    import _Primme
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x



__all__ = ['PrimmeParams', 'sprimme', 'cprimme', 'dprimme', 'zprimme', 'eigsh', 'PrimmeError', 'PRIMME_Arnoldi', 'PRIMME_DEFAULT_METHOD', 'PRIMME_DEFAULT_MIN_MATVECS', 'PRIMME_DEFAULT_MIN_TIME', 'PRIMME_DYNAMIC', 'PRIMME_GD', 'PRIMME_GD_Olsen_plusK', 'PRIMME_GD_plusK', 'PRIMME_JDQMR', 'PRIMME_JDQMR_ETol', 'PRIMME_JDQR', 'PRIMME_JD_Olsen_plusK', 'PRIMME_LOBPCG_OrthoBasis', 'PRIMME_LOBPCG_OrthoBasis_Window', 'PRIMME_RQI', 'PRIMME_STEEPEST_DESCENT', 'primme_adaptive', 'primme_adaptive_ETolerance', 'primme_closest_abs', 'primme_closest_geq', 'primme_closest_leq', 'primme_decreasing_LTolerance', 'primme_dtr', 'primme_full_LTolerance', 'primme_init_default', 'primme_init_krylov', 'primme_init_random', 'primme_init_user', 'primme_largest', 'primme_largest_abs', 'primme_proj_RR', 'primme_proj_default', 'primme_proj_harmonic', 'primme_proj_refined', 'primme_smallest', 'primme_thick', 'PrimmeSvdsParams', 'svds', 'primme_svds_augmented', 'primme_svds_closest_abs', 'primme_svds_default', 'primme_svds_hybrid', 'primme_svds_largest', 'primme_svds_normalequations', 'primme_svds_op_AAt', 'primme_svds_op_AtA', 'primme_svds_op_augmented', 'primme_svds_op_none', 'primme_svds_smallest', 'sprimme_svds', 'cprimme_svds', 'dprimme_svds', 'zprimme_svds', 'PrimmeSvdsError']

primme_smallest = _Primme.primme_smallest
primme_largest = _Primme.primme_largest
primme_closest_geq = _Primme.primme_closest_geq
primme_closest_leq = _Primme.primme_closest_leq
primme_closest_abs = _Primme.primme_closest_abs
primme_largest_abs = _Primme.primme_largest_abs
primme_proj_default = _Primme.primme_proj_default
primme_proj_RR = _Primme.primme_proj_RR
primme_proj_harmonic = _Primme.primme_proj_harmonic
primme_proj_refined = _Primme.primme_proj_refined
primme_init_default = _Primme.primme_init_default
primme_init_krylov = _Primme.primme_init_krylov
primme_init_random = _Primme.primme_init_random
primme_init_user = _Primme.primme_init_user
primme_thick = _Primme.primme_thick
primme_dtr = _Primme.primme_dtr
primme_full_LTolerance = _Primme.primme_full_LTolerance
primme_decreasing_LTolerance = _Primme.primme_decreasing_LTolerance
primme_adaptive_ETolerance = _Primme.primme_adaptive_ETolerance
primme_adaptive = _Primme.primme_adaptive
primme_event_outer_iteration = _Primme.primme_event_outer_iteration
primme_event_inner_iteration = _Primme.primme_event_inner_iteration
primme_event_restart = _Primme.primme_event_restart
primme_event_reset = _Primme.primme_event_reset
primme_event_converged = _Primme.primme_event_converged
primme_event_locked = _Primme.primme_event_locked
class primme_stats(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, primme_stats, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, primme_stats, name)
    __repr__ = _swig_repr
    __swig_setmethods__["numOuterIterations"] = _Primme.primme_stats_numOuterIterations_set
    __swig_getmethods__["numOuterIterations"] = _Primme.primme_stats_numOuterIterations_get
    if _newclass:
        numOuterIterations = _swig_property(_Primme.primme_stats_numOuterIterations_get, _Primme.primme_stats_numOuterIterations_set)
    __swig_setmethods__["numRestarts"] = _Primme.primme_stats_numRestarts_set
    __swig_getmethods__["numRestarts"] = _Primme.primme_stats_numRestarts_get
    if _newclass:
        numRestarts = _swig_property(_Primme.primme_stats_numRestarts_get, _Primme.primme_stats_numRestarts_set)
    __swig_setmethods__["numMatvecs"] = _Primme.primme_stats_numMatvecs_set
    __swig_getmethods__["numMatvecs"] = _Primme.primme_stats_numMatvecs_get
    if _newclass:
        numMatvecs = _swig_property(_Primme.primme_stats_numMatvecs_get, _Primme.primme_stats_numMatvecs_set)
    __swig_setmethods__["numPreconds"] = _Primme.primme_stats_numPreconds_set
    __swig_getmethods__["numPreconds"] = _Primme.primme_stats_numPreconds_get
    if _newclass:
        numPreconds = _swig_property(_Primme.primme_stats_numPreconds_get, _Primme.primme_stats_numPreconds_set)
    __swig_setmethods__["numGlobalSum"] = _Primme.primme_stats_numGlobalSum_set
    __swig_getmethods__["numGlobalSum"] = _Primme.primme_stats_numGlobalSum_get
    if _newclass:
        numGlobalSum = _swig_property(_Primme.primme_stats_numGlobalSum_get, _Primme.primme_stats_numGlobalSum_set)
    __swig_setmethods__["volumeGlobalSum"] = _Primme.primme_stats_volumeGlobalSum_set
    __swig_getmethods__["volumeGlobalSum"] = _Primme.primme_stats_volumeGlobalSum_get
    if _newclass:
        volumeGlobalSum = _swig_property(_Primme.primme_stats_volumeGlobalSum_get, _Primme.primme_stats_volumeGlobalSum_set)
    __swig_setmethods__["numOrthoInnerProds"] = _Primme.primme_stats_numOrthoInnerProds_set
    __swig_getmethods__["numOrthoInnerProds"] = _Primme.primme_stats_numOrthoInnerProds_get
    if _newclass:
        numOrthoInnerProds = _swig_property(_Primme.primme_stats_numOrthoInnerProds_get, _Primme.primme_stats_numOrthoInnerProds_set)
    __swig_setmethods__["elapsedTime"] = _Primme.primme_stats_elapsedTime_set
    __swig_getmethods__["elapsedTime"] = _Primme.primme_stats_elapsedTime_get
    if _newclass:
        elapsedTime = _swig_property(_Primme.primme_stats_elapsedTime_get, _Primme.primme_stats_elapsedTime_set)
    __swig_setmethods__["timeMatvec"] = _Primme.primme_stats_timeMatvec_set
    __swig_getmethods__["timeMatvec"] = _Primme.primme_stats_timeMatvec_get
    if _newclass:
        timeMatvec = _swig_property(_Primme.primme_stats_timeMatvec_get, _Primme.primme_stats_timeMatvec_set)
    __swig_setmethods__["timePrecond"] = _Primme.primme_stats_timePrecond_set
    __swig_getmethods__["timePrecond"] = _Primme.primme_stats_timePrecond_get
    if _newclass:
        timePrecond = _swig_property(_Primme.primme_stats_timePrecond_get, _Primme.primme_stats_timePrecond_set)
    __swig_setmethods__["timeOrtho"] = _Primme.primme_stats_timeOrtho_set
    __swig_getmethods__["timeOrtho"] = _Primme.primme_stats_timeOrtho_get
    if _newclass:
        timeOrtho = _swig_property(_Primme.primme_stats_timeOrtho_get, _Primme.primme_stats_timeOrtho_set)
    __swig_setmethods__["timeGlobalSum"] = _Primme.primme_stats_timeGlobalSum_set
    __swig_getmethods__["timeGlobalSum"] = _Primme.primme_stats_timeGlobalSum_get
    if _newclass:
        timeGlobalSum = _swig_property(_Primme.primme_stats_timeGlobalSum_get, _Primme.primme_stats_timeGlobalSum_set)
    __swig_setmethods__["estimateMinEVal"] = _Primme.primme_stats_estimateMinEVal_set
    __swig_getmethods__["estimateMinEVal"] = _Primme.primme_stats_estimateMinEVal_get
    if _newclass:
        estimateMinEVal = _swig_property(_Primme.primme_stats_estimateMinEVal_get, _Primme.primme_stats_estimateMinEVal_set)
    __swig_setmethods__["estimateMaxEVal"] = _Primme.primme_stats_estimateMaxEVal_set
    __swig_getmethods__["estimateMaxEVal"] = _Primme.primme_stats_estimateMaxEVal_get
    if _newclass:
        estimateMaxEVal = _swig_property(_Primme.primme_stats_estimateMaxEVal_get, _Primme.primme_stats_estimateMaxEVal_set)
    __swig_setmethods__["estimateLargestSVal"] = _Primme.primme_stats_estimateLargestSVal_set
    __swig_getmethods__["estimateLargestSVal"] = _Primme.primme_stats_estimateLargestSVal_get
    if _newclass:
        estimateLargestSVal = _swig_property(_Primme.primme_stats_estimateLargestSVal_get, _Primme.primme_stats_estimateLargestSVal_set)
    __swig_setmethods__["maxConvTol"] = _Primme.primme_stats_maxConvTol_set
    __swig_getmethods__["maxConvTol"] = _Primme.primme_stats_maxConvTol_get
    if _newclass:
        maxConvTol = _swig_property(_Primme.primme_stats_maxConvTol_get, _Primme.primme_stats_maxConvTol_set)
    __swig_setmethods__["estimateResidualError"] = _Primme.primme_stats_estimateResidualError_set
    __swig_getmethods__["estimateResidualError"] = _Primme.primme_stats_estimateResidualError_get
    if _newclass:
        estimateResidualError = _swig_property(_Primme.primme_stats_estimateResidualError_get, _Primme.primme_stats_estimateResidualError_set)

    def __init__(self):
        this = _Primme.new_primme_stats()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_primme_stats
    __del__ = lambda self: None
primme_stats_swigregister = _Primme.primme_stats_swigregister
primme_stats_swigregister(primme_stats)

class JD_projectors(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, JD_projectors, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, JD_projectors, name)
    __repr__ = _swig_repr
    __swig_setmethods__["LeftQ"] = _Primme.JD_projectors_LeftQ_set
    __swig_getmethods__["LeftQ"] = _Primme.JD_projectors_LeftQ_get
    if _newclass:
        LeftQ = _swig_property(_Primme.JD_projectors_LeftQ_get, _Primme.JD_projectors_LeftQ_set)
    __swig_setmethods__["LeftX"] = _Primme.JD_projectors_LeftX_set
    __swig_getmethods__["LeftX"] = _Primme.JD_projectors_LeftX_get
    if _newclass:
        LeftX = _swig_property(_Primme.JD_projectors_LeftX_get, _Primme.JD_projectors_LeftX_set)
    __swig_setmethods__["RightQ"] = _Primme.JD_projectors_RightQ_set
    __swig_getmethods__["RightQ"] = _Primme.JD_projectors_RightQ_get
    if _newclass:
        RightQ = _swig_property(_Primme.JD_projectors_RightQ_get, _Primme.JD_projectors_RightQ_set)
    __swig_setmethods__["RightX"] = _Primme.JD_projectors_RightX_set
    __swig_getmethods__["RightX"] = _Primme.JD_projectors_RightX_get
    if _newclass:
        RightX = _swig_property(_Primme.JD_projectors_RightX_get, _Primme.JD_projectors_RightX_set)
    __swig_setmethods__["SkewQ"] = _Primme.JD_projectors_SkewQ_set
    __swig_getmethods__["SkewQ"] = _Primme.JD_projectors_SkewQ_get
    if _newclass:
        SkewQ = _swig_property(_Primme.JD_projectors_SkewQ_get, _Primme.JD_projectors_SkewQ_set)
    __swig_setmethods__["SkewX"] = _Primme.JD_projectors_SkewX_set
    __swig_getmethods__["SkewX"] = _Primme.JD_projectors_SkewX_get
    if _newclass:
        SkewX = _swig_property(_Primme.JD_projectors_SkewX_get, _Primme.JD_projectors_SkewX_set)

    def __init__(self):
        this = _Primme.new_JD_projectors()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_JD_projectors
    __del__ = lambda self: None
JD_projectors_swigregister = _Primme.JD_projectors_swigregister
JD_projectors_swigregister(JD_projectors)

class projection_params(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, projection_params, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, projection_params, name)
    __repr__ = _swig_repr
    __swig_setmethods__["projection"] = _Primme.projection_params_projection_set
    __swig_getmethods__["projection"] = _Primme.projection_params_projection_get
    if _newclass:
        projection = _swig_property(_Primme.projection_params_projection_get, _Primme.projection_params_projection_set)

    def __init__(self):
        this = _Primme.new_projection_params()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_projection_params
    __del__ = lambda self: None
projection_params_swigregister = _Primme.projection_params_swigregister
projection_params_swigregister(projection_params)

class correction_params(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, correction_params, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, correction_params, name)
    __repr__ = _swig_repr
    __swig_setmethods__["precondition"] = _Primme.correction_params_precondition_set
    __swig_getmethods__["precondition"] = _Primme.correction_params_precondition_get
    if _newclass:
        precondition = _swig_property(_Primme.correction_params_precondition_get, _Primme.correction_params_precondition_set)
    __swig_setmethods__["robustShifts"] = _Primme.correction_params_robustShifts_set
    __swig_getmethods__["robustShifts"] = _Primme.correction_params_robustShifts_get
    if _newclass:
        robustShifts = _swig_property(_Primme.correction_params_robustShifts_get, _Primme.correction_params_robustShifts_set)
    __swig_setmethods__["maxInnerIterations"] = _Primme.correction_params_maxInnerIterations_set
    __swig_getmethods__["maxInnerIterations"] = _Primme.correction_params_maxInnerIterations_get
    if _newclass:
        maxInnerIterations = _swig_property(_Primme.correction_params_maxInnerIterations_get, _Primme.correction_params_maxInnerIterations_set)
    __swig_setmethods__["projectors"] = _Primme.correction_params_projectors_set
    __swig_getmethods__["projectors"] = _Primme.correction_params_projectors_get
    if _newclass:
        projectors = _swig_property(_Primme.correction_params_projectors_get, _Primme.correction_params_projectors_set)
    __swig_setmethods__["convTest"] = _Primme.correction_params_convTest_set
    __swig_getmethods__["convTest"] = _Primme.correction_params_convTest_get
    if _newclass:
        convTest = _swig_property(_Primme.correction_params_convTest_get, _Primme.correction_params_convTest_set)
    __swig_setmethods__["relTolBase"] = _Primme.correction_params_relTolBase_set
    __swig_getmethods__["relTolBase"] = _Primme.correction_params_relTolBase_get
    if _newclass:
        relTolBase = _swig_property(_Primme.correction_params_relTolBase_get, _Primme.correction_params_relTolBase_set)

    def __init__(self):
        this = _Primme.new_correction_params()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_correction_params
    __del__ = lambda self: None
correction_params_swigregister = _Primme.correction_params_swigregister
correction_params_swigregister(correction_params)

class restarting_params(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, restarting_params, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, restarting_params, name)
    __repr__ = _swig_repr
    __swig_setmethods__["scheme"] = _Primme.restarting_params_scheme_set
    __swig_getmethods__["scheme"] = _Primme.restarting_params_scheme_get
    if _newclass:
        scheme = _swig_property(_Primme.restarting_params_scheme_get, _Primme.restarting_params_scheme_set)
    __swig_setmethods__["maxPrevRetain"] = _Primme.restarting_params_maxPrevRetain_set
    __swig_getmethods__["maxPrevRetain"] = _Primme.restarting_params_maxPrevRetain_get
    if _newclass:
        maxPrevRetain = _swig_property(_Primme.restarting_params_maxPrevRetain_get, _Primme.restarting_params_maxPrevRetain_set)

    def __init__(self):
        this = _Primme.new_restarting_params()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_restarting_params
    __del__ = lambda self: None
restarting_params_swigregister = _Primme.restarting_params_swigregister
restarting_params_swigregister(restarting_params)

class primme_params(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, primme_params, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, primme_params, name)
    __repr__ = _swig_repr
    __swig_setmethods__["n"] = _Primme.primme_params_n_set
    __swig_getmethods__["n"] = _Primme.primme_params_n_get
    if _newclass:
        n = _swig_property(_Primme.primme_params_n_get, _Primme.primme_params_n_set)
    __swig_setmethods__["numProcs"] = _Primme.primme_params_numProcs_set
    __swig_getmethods__["numProcs"] = _Primme.primme_params_numProcs_get
    if _newclass:
        numProcs = _swig_property(_Primme.primme_params_numProcs_get, _Primme.primme_params_numProcs_set)
    __swig_setmethods__["procID"] = _Primme.primme_params_procID_set
    __swig_getmethods__["procID"] = _Primme.primme_params_procID_get
    if _newclass:
        procID = _swig_property(_Primme.primme_params_procID_get, _Primme.primme_params_procID_set)
    __swig_setmethods__["nLocal"] = _Primme.primme_params_nLocal_set
    __swig_getmethods__["nLocal"] = _Primme.primme_params_nLocal_get
    if _newclass:
        nLocal = _swig_property(_Primme.primme_params_nLocal_get, _Primme.primme_params_nLocal_set)
    __swig_setmethods__["globalSumReal"] = _Primme.primme_params_globalSumReal_set
    __swig_getmethods__["globalSumReal"] = _Primme.primme_params_globalSumReal_get
    if _newclass:
        globalSumReal = _swig_property(_Primme.primme_params_globalSumReal_get, _Primme.primme_params_globalSumReal_set)
    __swig_setmethods__["numEvals"] = _Primme.primme_params_numEvals_set
    __swig_getmethods__["numEvals"] = _Primme.primme_params_numEvals_get
    if _newclass:
        numEvals = _swig_property(_Primme.primme_params_numEvals_get, _Primme.primme_params_numEvals_set)
    __swig_setmethods__["target"] = _Primme.primme_params_target_set
    __swig_getmethods__["target"] = _Primme.primme_params_target_get
    if _newclass:
        target = _swig_property(_Primme.primme_params_target_get, _Primme.primme_params_target_set)
    __swig_setmethods__["dynamicMethodSwitch"] = _Primme.primme_params_dynamicMethodSwitch_set
    __swig_getmethods__["dynamicMethodSwitch"] = _Primme.primme_params_dynamicMethodSwitch_get
    if _newclass:
        dynamicMethodSwitch = _swig_property(_Primme.primme_params_dynamicMethodSwitch_get, _Primme.primme_params_dynamicMethodSwitch_set)
    __swig_setmethods__["locking"] = _Primme.primme_params_locking_set
    __swig_getmethods__["locking"] = _Primme.primme_params_locking_get
    if _newclass:
        locking = _swig_property(_Primme.primme_params_locking_get, _Primme.primme_params_locking_set)
    __swig_setmethods__["initSize"] = _Primme.primme_params_initSize_set
    __swig_getmethods__["initSize"] = _Primme.primme_params_initSize_get
    if _newclass:
        initSize = _swig_property(_Primme.primme_params_initSize_get, _Primme.primme_params_initSize_set)
    __swig_setmethods__["numOrthoConst"] = _Primme.primme_params_numOrthoConst_set
    __swig_getmethods__["numOrthoConst"] = _Primme.primme_params_numOrthoConst_get
    if _newclass:
        numOrthoConst = _swig_property(_Primme.primme_params_numOrthoConst_get, _Primme.primme_params_numOrthoConst_set)
    __swig_setmethods__["maxBasisSize"] = _Primme.primme_params_maxBasisSize_set
    __swig_getmethods__["maxBasisSize"] = _Primme.primme_params_maxBasisSize_get
    if _newclass:
        maxBasisSize = _swig_property(_Primme.primme_params_maxBasisSize_get, _Primme.primme_params_maxBasisSize_set)
    __swig_setmethods__["minRestartSize"] = _Primme.primme_params_minRestartSize_set
    __swig_getmethods__["minRestartSize"] = _Primme.primme_params_minRestartSize_get
    if _newclass:
        minRestartSize = _swig_property(_Primme.primme_params_minRestartSize_get, _Primme.primme_params_minRestartSize_set)
    __swig_setmethods__["maxBlockSize"] = _Primme.primme_params_maxBlockSize_set
    __swig_getmethods__["maxBlockSize"] = _Primme.primme_params_maxBlockSize_get
    if _newclass:
        maxBlockSize = _swig_property(_Primme.primme_params_maxBlockSize_get, _Primme.primme_params_maxBlockSize_set)
    __swig_setmethods__["maxMatvecs"] = _Primme.primme_params_maxMatvecs_set
    __swig_getmethods__["maxMatvecs"] = _Primme.primme_params_maxMatvecs_get
    if _newclass:
        maxMatvecs = _swig_property(_Primme.primme_params_maxMatvecs_get, _Primme.primme_params_maxMatvecs_set)
    __swig_setmethods__["maxOuterIterations"] = _Primme.primme_params_maxOuterIterations_set
    __swig_getmethods__["maxOuterIterations"] = _Primme.primme_params_maxOuterIterations_get
    if _newclass:
        maxOuterIterations = _swig_property(_Primme.primme_params_maxOuterIterations_get, _Primme.primme_params_maxOuterIterations_set)
    __swig_setmethods__["intWorkSize"] = _Primme.primme_params_intWorkSize_set
    __swig_getmethods__["intWorkSize"] = _Primme.primme_params_intWorkSize_get
    if _newclass:
        intWorkSize = _swig_property(_Primme.primme_params_intWorkSize_get, _Primme.primme_params_intWorkSize_set)
    __swig_setmethods__["realWorkSize"] = _Primme.primme_params_realWorkSize_set
    __swig_getmethods__["realWorkSize"] = _Primme.primme_params_realWorkSize_get
    if _newclass:
        realWorkSize = _swig_property(_Primme.primme_params_realWorkSize_get, _Primme.primme_params_realWorkSize_set)
    __swig_setmethods__["iseed"] = _Primme.primme_params_iseed_set
    __swig_getmethods__["iseed"] = _Primme.primme_params_iseed_get
    if _newclass:
        iseed = _swig_property(_Primme.primme_params_iseed_get, _Primme.primme_params_iseed_set)
    __swig_setmethods__["aNorm"] = _Primme.primme_params_aNorm_set
    __swig_getmethods__["aNorm"] = _Primme.primme_params_aNorm_get
    if _newclass:
        aNorm = _swig_property(_Primme.primme_params_aNorm_get, _Primme.primme_params_aNorm_set)
    __swig_setmethods__["eps"] = _Primme.primme_params_eps_set
    __swig_getmethods__["eps"] = _Primme.primme_params_eps_get
    if _newclass:
        eps = _swig_property(_Primme.primme_params_eps_get, _Primme.primme_params_eps_set)
    __swig_setmethods__["printLevel"] = _Primme.primme_params_printLevel_set
    __swig_getmethods__["printLevel"] = _Primme.primme_params_printLevel_get
    if _newclass:
        printLevel = _swig_property(_Primme.primme_params_printLevel_get, _Primme.primme_params_printLevel_set)
    __swig_setmethods__["initBasisMode"] = _Primme.primme_params_initBasisMode_set
    __swig_getmethods__["initBasisMode"] = _Primme.primme_params_initBasisMode_get
    if _newclass:
        initBasisMode = _swig_property(_Primme.primme_params_initBasisMode_get, _Primme.primme_params_initBasisMode_set)
    __swig_setmethods__["ldevecs"] = _Primme.primme_params_ldevecs_set
    __swig_getmethods__["ldevecs"] = _Primme.primme_params_ldevecs_get
    if _newclass:
        ldevecs = _swig_property(_Primme.primme_params_ldevecs_get, _Primme.primme_params_ldevecs_set)
    __swig_setmethods__["ldOPs"] = _Primme.primme_params_ldOPs_set
    __swig_getmethods__["ldOPs"] = _Primme.primme_params_ldOPs_get
    if _newclass:
        ldOPs = _swig_property(_Primme.primme_params_ldOPs_get, _Primme.primme_params_ldOPs_set)
    __swig_setmethods__["projectionParams"] = _Primme.primme_params_projectionParams_set
    __swig_getmethods__["projectionParams"] = _Primme.primme_params_projectionParams_get
    if _newclass:
        projectionParams = _swig_property(_Primme.primme_params_projectionParams_get, _Primme.primme_params_projectionParams_set)
    __swig_setmethods__["restartingParams"] = _Primme.primme_params_restartingParams_set
    __swig_getmethods__["restartingParams"] = _Primme.primme_params_restartingParams_get
    if _newclass:
        restartingParams = _swig_property(_Primme.primme_params_restartingParams_get, _Primme.primme_params_restartingParams_set)
    __swig_setmethods__["correctionParams"] = _Primme.primme_params_correctionParams_set
    __swig_getmethods__["correctionParams"] = _Primme.primme_params_correctionParams_get
    if _newclass:
        correctionParams = _swig_property(_Primme.primme_params_correctionParams_get, _Primme.primme_params_correctionParams_set)
    __swig_setmethods__["stats"] = _Primme.primme_params_stats_set
    __swig_getmethods__["stats"] = _Primme.primme_params_stats_get
    if _newclass:
        stats = _swig_property(_Primme.primme_params_stats_get, _Primme.primme_params_stats_set)
    __swig_setmethods__["convtest"] = _Primme.primme_params_convtest_set
    __swig_getmethods__["convtest"] = _Primme.primme_params_convtest_get
    if _newclass:
        convtest = _swig_property(_Primme.primme_params_convtest_get, _Primme.primme_params_convtest_set)

    def __init__(self):
        this = _Primme.new_primme_params()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_primme_params
    __del__ = lambda self: None
primme_params_swigregister = _Primme.primme_params_swigregister
primme_params_swigregister(primme_params)

PRIMME_DEFAULT_METHOD = _Primme.PRIMME_DEFAULT_METHOD
PRIMME_DYNAMIC = _Primme.PRIMME_DYNAMIC
PRIMME_DEFAULT_MIN_TIME = _Primme.PRIMME_DEFAULT_MIN_TIME
PRIMME_DEFAULT_MIN_MATVECS = _Primme.PRIMME_DEFAULT_MIN_MATVECS
PRIMME_Arnoldi = _Primme.PRIMME_Arnoldi
PRIMME_GD = _Primme.PRIMME_GD
PRIMME_GD_plusK = _Primme.PRIMME_GD_plusK
PRIMME_GD_Olsen_plusK = _Primme.PRIMME_GD_Olsen_plusK
PRIMME_JD_Olsen_plusK = _Primme.PRIMME_JD_Olsen_plusK
PRIMME_RQI = _Primme.PRIMME_RQI
PRIMME_JDQR = _Primme.PRIMME_JDQR
PRIMME_JDQMR = _Primme.PRIMME_JDQMR
PRIMME_JDQMR_ETol = _Primme.PRIMME_JDQMR_ETol
PRIMME_STEEPEST_DESCENT = _Primme.PRIMME_STEEPEST_DESCENT
PRIMME_LOBPCG_OrthoBasis = _Primme.PRIMME_LOBPCG_OrthoBasis
PRIMME_LOBPCG_OrthoBasis_Window = _Primme.PRIMME_LOBPCG_OrthoBasis_Window
primme_int = _Primme.primme_int
primme_double = _Primme.primme_double
primme_pointer = _Primme.primme_pointer
PRIMME_n = _Primme.PRIMME_n
PRIMME_matrixMatvec = _Primme.PRIMME_matrixMatvec
PRIMME_applyPreconditioner = _Primme.PRIMME_applyPreconditioner
PRIMME_numProcs = _Primme.PRIMME_numProcs
PRIMME_procID = _Primme.PRIMME_procID
PRIMME_commInfo = _Primme.PRIMME_commInfo
PRIMME_nLocal = _Primme.PRIMME_nLocal
PRIMME_globalSumReal = _Primme.PRIMME_globalSumReal
PRIMME_numEvals = _Primme.PRIMME_numEvals
PRIMME_target = _Primme.PRIMME_target
PRIMME_numTargetShifts = _Primme.PRIMME_numTargetShifts
PRIMME_targetShifts = _Primme.PRIMME_targetShifts
PRIMME_locking = _Primme.PRIMME_locking
PRIMME_initSize = _Primme.PRIMME_initSize
PRIMME_numOrthoConst = _Primme.PRIMME_numOrthoConst
PRIMME_maxBasisSize = _Primme.PRIMME_maxBasisSize
PRIMME_minRestartSize = _Primme.PRIMME_minRestartSize
PRIMME_maxBlockSize = _Primme.PRIMME_maxBlockSize
PRIMME_maxMatvecs = _Primme.PRIMME_maxMatvecs
PRIMME_maxOuterIterations = _Primme.PRIMME_maxOuterIterations
PRIMME_intWorkSize = _Primme.PRIMME_intWorkSize
PRIMME_realWorkSize = _Primme.PRIMME_realWorkSize
PRIMME_iseed = _Primme.PRIMME_iseed
PRIMME_intWork = _Primme.PRIMME_intWork
PRIMME_realWork = _Primme.PRIMME_realWork
PRIMME_aNorm = _Primme.PRIMME_aNorm
PRIMME_eps = _Primme.PRIMME_eps
PRIMME_printLevel = _Primme.PRIMME_printLevel
PRIMME_outputFile = _Primme.PRIMME_outputFile
PRIMME_matrix = _Primme.PRIMME_matrix
PRIMME_preconditioner = _Primme.PRIMME_preconditioner
PRIMME_initBasisMode = _Primme.PRIMME_initBasisMode
PRIMME_projectionParams_projection = _Primme.PRIMME_projectionParams_projection
PRIMME_restartingParams_scheme = _Primme.PRIMME_restartingParams_scheme
PRIMME_restartingParams_maxPrevRetain = _Primme.PRIMME_restartingParams_maxPrevRetain
PRIMME_correctionParams_precondition = _Primme.PRIMME_correctionParams_precondition
PRIMME_correctionParams_robustShifts = _Primme.PRIMME_correctionParams_robustShifts
PRIMME_correctionParams_maxInnerIterations = _Primme.PRIMME_correctionParams_maxInnerIterations
PRIMME_correctionParams_projectors_LeftQ = _Primme.PRIMME_correctionParams_projectors_LeftQ
PRIMME_correctionParams_projectors_LeftX = _Primme.PRIMME_correctionParams_projectors_LeftX
PRIMME_correctionParams_projectors_RightQ = _Primme.PRIMME_correctionParams_projectors_RightQ
PRIMME_correctionParams_projectors_RightX = _Primme.PRIMME_correctionParams_projectors_RightX
PRIMME_correctionParams_projectors_SkewQ = _Primme.PRIMME_correctionParams_projectors_SkewQ
PRIMME_correctionParams_projectors_SkewX = _Primme.PRIMME_correctionParams_projectors_SkewX
PRIMME_correctionParams_convTest = _Primme.PRIMME_correctionParams_convTest
PRIMME_correctionParams_relTolBase = _Primme.PRIMME_correctionParams_relTolBase
PRIMME_stats_numOuterIterations = _Primme.PRIMME_stats_numOuterIterations
PRIMME_stats_numRestarts = _Primme.PRIMME_stats_numRestarts
PRIMME_stats_numMatvecs = _Primme.PRIMME_stats_numMatvecs
PRIMME_stats_numPreconds = _Primme.PRIMME_stats_numPreconds
PRIMME_stats_numGlobalSum = _Primme.PRIMME_stats_numGlobalSum
PRIMME_stats_volumeGlobalSum = _Primme.PRIMME_stats_volumeGlobalSum
PRIMME_stats_numOrthoInnerProds = _Primme.PRIMME_stats_numOrthoInnerProds
PRIMME_stats_elapsedTime = _Primme.PRIMME_stats_elapsedTime
PRIMME_stats_timeMatvec = _Primme.PRIMME_stats_timeMatvec
PRIMME_stats_timePrecond = _Primme.PRIMME_stats_timePrecond
PRIMME_stats_timeOrtho = _Primme.PRIMME_stats_timeOrtho
PRIMME_stats_timeGlobalSum = _Primme.PRIMME_stats_timeGlobalSum
PRIMME_stats_estimateMinEVal = _Primme.PRIMME_stats_estimateMinEVal
PRIMME_stats_estimateMaxEVal = _Primme.PRIMME_stats_estimateMaxEVal
PRIMME_stats_estimateLargestSVal = _Primme.PRIMME_stats_estimateLargestSVal
PRIMME_stats_maxConvTol = _Primme.PRIMME_stats_maxConvTol
PRIMME_dynamicMethodSwitch = _Primme.PRIMME_dynamicMethodSwitch
PRIMME_massMatrixMatvec = _Primme.PRIMME_massMatrixMatvec
PRIMME_convTestFun = _Primme.PRIMME_convTestFun
PRIMME_ldevecs = _Primme.PRIMME_ldevecs
PRIMME_ldOPs = _Primme.PRIMME_ldOPs
PRIMME_monitorFun = _Primme.PRIMME_monitorFun
PRIMME_monitor = _Primme.PRIMME_monitor

def sprimme(*args):
    return _Primme.sprimme(*args)
sprimme = _Primme.sprimme

def cprimme(*args):
    return _Primme.cprimme(*args)
cprimme = _Primme.cprimme

def dprimme(*args):
    return _Primme.dprimme(*args)
dprimme = _Primme.dprimme

def zprimme(*args):
    return _Primme.zprimme(*args)
zprimme = _Primme.zprimme

def primme_get_member(primme, label, value):
    return _Primme.primme_get_member(primme, label, value)
primme_get_member = _Primme.primme_get_member

def primme_set_member(primme, label, value):
    return _Primme.primme_set_member(primme, label, value)
primme_set_member = _Primme.primme_set_member

def primme_member_info(label, label_name, type, arity):
    return _Primme.primme_member_info(label, label_name, type, arity)
primme_member_info = _Primme.primme_member_info

def primme_constant_info(label_name, value):
    return _Primme.primme_constant_info(label_name, value)
primme_constant_info = _Primme.primme_constant_info
primme_svds_largest = _Primme.primme_svds_largest
primme_svds_smallest = _Primme.primme_svds_smallest
primme_svds_closest_abs = _Primme.primme_svds_closest_abs
primme_svds_default = _Primme.primme_svds_default
primme_svds_hybrid = _Primme.primme_svds_hybrid
primme_svds_normalequations = _Primme.primme_svds_normalequations
primme_svds_augmented = _Primme.primme_svds_augmented
primme_svds_op_none = _Primme.primme_svds_op_none
primme_svds_op_AtA = _Primme.primme_svds_op_AtA
primme_svds_op_AAt = _Primme.primme_svds_op_AAt
primme_svds_op_augmented = _Primme.primme_svds_op_augmented
class primme_svds_stats(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, primme_svds_stats, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, primme_svds_stats, name)
    __repr__ = _swig_repr
    __swig_setmethods__["numOuterIterations"] = _Primme.primme_svds_stats_numOuterIterations_set
    __swig_getmethods__["numOuterIterations"] = _Primme.primme_svds_stats_numOuterIterations_get
    if _newclass:
        numOuterIterations = _swig_property(_Primme.primme_svds_stats_numOuterIterations_get, _Primme.primme_svds_stats_numOuterIterations_set)
    __swig_setmethods__["numRestarts"] = _Primme.primme_svds_stats_numRestarts_set
    __swig_getmethods__["numRestarts"] = _Primme.primme_svds_stats_numRestarts_get
    if _newclass:
        numRestarts = _swig_property(_Primme.primme_svds_stats_numRestarts_get, _Primme.primme_svds_stats_numRestarts_set)
    __swig_setmethods__["numMatvecs"] = _Primme.primme_svds_stats_numMatvecs_set
    __swig_getmethods__["numMatvecs"] = _Primme.primme_svds_stats_numMatvecs_get
    if _newclass:
        numMatvecs = _swig_property(_Primme.primme_svds_stats_numMatvecs_get, _Primme.primme_svds_stats_numMatvecs_set)
    __swig_setmethods__["numPreconds"] = _Primme.primme_svds_stats_numPreconds_set
    __swig_getmethods__["numPreconds"] = _Primme.primme_svds_stats_numPreconds_get
    if _newclass:
        numPreconds = _swig_property(_Primme.primme_svds_stats_numPreconds_get, _Primme.primme_svds_stats_numPreconds_set)
    __swig_setmethods__["numGlobalSum"] = _Primme.primme_svds_stats_numGlobalSum_set
    __swig_getmethods__["numGlobalSum"] = _Primme.primme_svds_stats_numGlobalSum_get
    if _newclass:
        numGlobalSum = _swig_property(_Primme.primme_svds_stats_numGlobalSum_get, _Primme.primme_svds_stats_numGlobalSum_set)
    __swig_setmethods__["volumeGlobalSum"] = _Primme.primme_svds_stats_volumeGlobalSum_set
    __swig_getmethods__["volumeGlobalSum"] = _Primme.primme_svds_stats_volumeGlobalSum_get
    if _newclass:
        volumeGlobalSum = _swig_property(_Primme.primme_svds_stats_volumeGlobalSum_get, _Primme.primme_svds_stats_volumeGlobalSum_set)
    __swig_setmethods__["numOrthoInnerProds"] = _Primme.primme_svds_stats_numOrthoInnerProds_set
    __swig_getmethods__["numOrthoInnerProds"] = _Primme.primme_svds_stats_numOrthoInnerProds_get
    if _newclass:
        numOrthoInnerProds = _swig_property(_Primme.primme_svds_stats_numOrthoInnerProds_get, _Primme.primme_svds_stats_numOrthoInnerProds_set)
    __swig_setmethods__["elapsedTime"] = _Primme.primme_svds_stats_elapsedTime_set
    __swig_getmethods__["elapsedTime"] = _Primme.primme_svds_stats_elapsedTime_get
    if _newclass:
        elapsedTime = _swig_property(_Primme.primme_svds_stats_elapsedTime_get, _Primme.primme_svds_stats_elapsedTime_set)
    __swig_setmethods__["timeMatvec"] = _Primme.primme_svds_stats_timeMatvec_set
    __swig_getmethods__["timeMatvec"] = _Primme.primme_svds_stats_timeMatvec_get
    if _newclass:
        timeMatvec = _swig_property(_Primme.primme_svds_stats_timeMatvec_get, _Primme.primme_svds_stats_timeMatvec_set)
    __swig_setmethods__["timePrecond"] = _Primme.primme_svds_stats_timePrecond_set
    __swig_getmethods__["timePrecond"] = _Primme.primme_svds_stats_timePrecond_get
    if _newclass:
        timePrecond = _swig_property(_Primme.primme_svds_stats_timePrecond_get, _Primme.primme_svds_stats_timePrecond_set)
    __swig_setmethods__["timeOrtho"] = _Primme.primme_svds_stats_timeOrtho_set
    __swig_getmethods__["timeOrtho"] = _Primme.primme_svds_stats_timeOrtho_get
    if _newclass:
        timeOrtho = _swig_property(_Primme.primme_svds_stats_timeOrtho_get, _Primme.primme_svds_stats_timeOrtho_set)
    __swig_setmethods__["timeGlobalSum"] = _Primme.primme_svds_stats_timeGlobalSum_set
    __swig_getmethods__["timeGlobalSum"] = _Primme.primme_svds_stats_timeGlobalSum_get
    if _newclass:
        timeGlobalSum = _swig_property(_Primme.primme_svds_stats_timeGlobalSum_get, _Primme.primme_svds_stats_timeGlobalSum_set)

    def __init__(self):
        this = _Primme.new_primme_svds_stats()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_primme_svds_stats
    __del__ = lambda self: None
primme_svds_stats_swigregister = _Primme.primme_svds_stats_swigregister
primme_svds_stats_swigregister(primme_svds_stats)

class primme_svds_params(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, primme_svds_params, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, primme_svds_params, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m"] = _Primme.primme_svds_params_m_set
    __swig_getmethods__["m"] = _Primme.primme_svds_params_m_get
    if _newclass:
        m = _swig_property(_Primme.primme_svds_params_m_get, _Primme.primme_svds_params_m_set)
    __swig_setmethods__["n"] = _Primme.primme_svds_params_n_set
    __swig_getmethods__["n"] = _Primme.primme_svds_params_n_get
    if _newclass:
        n = _swig_property(_Primme.primme_svds_params_n_get, _Primme.primme_svds_params_n_set)
    __swig_setmethods__["numProcs"] = _Primme.primme_svds_params_numProcs_set
    __swig_getmethods__["numProcs"] = _Primme.primme_svds_params_numProcs_get
    if _newclass:
        numProcs = _swig_property(_Primme.primme_svds_params_numProcs_get, _Primme.primme_svds_params_numProcs_set)
    __swig_setmethods__["procID"] = _Primme.primme_svds_params_procID_set
    __swig_getmethods__["procID"] = _Primme.primme_svds_params_procID_get
    if _newclass:
        procID = _swig_property(_Primme.primme_svds_params_procID_get, _Primme.primme_svds_params_procID_set)
    __swig_setmethods__["mLocal"] = _Primme.primme_svds_params_mLocal_set
    __swig_getmethods__["mLocal"] = _Primme.primme_svds_params_mLocal_get
    if _newclass:
        mLocal = _swig_property(_Primme.primme_svds_params_mLocal_get, _Primme.primme_svds_params_mLocal_set)
    __swig_setmethods__["nLocal"] = _Primme.primme_svds_params_nLocal_set
    __swig_getmethods__["nLocal"] = _Primme.primme_svds_params_nLocal_get
    if _newclass:
        nLocal = _swig_property(_Primme.primme_svds_params_nLocal_get, _Primme.primme_svds_params_nLocal_set)
    __swig_setmethods__["globalSumReal"] = _Primme.primme_svds_params_globalSumReal_set
    __swig_getmethods__["globalSumReal"] = _Primme.primme_svds_params_globalSumReal_get
    if _newclass:
        globalSumReal = _swig_property(_Primme.primme_svds_params_globalSumReal_get, _Primme.primme_svds_params_globalSumReal_set)
    __swig_setmethods__["numSvals"] = _Primme.primme_svds_params_numSvals_set
    __swig_getmethods__["numSvals"] = _Primme.primme_svds_params_numSvals_get
    if _newclass:
        numSvals = _swig_property(_Primme.primme_svds_params_numSvals_get, _Primme.primme_svds_params_numSvals_set)
    __swig_setmethods__["target"] = _Primme.primme_svds_params_target_set
    __swig_getmethods__["target"] = _Primme.primme_svds_params_target_get
    if _newclass:
        target = _swig_property(_Primme.primme_svds_params_target_get, _Primme.primme_svds_params_target_set)
    __swig_setmethods__["method"] = _Primme.primme_svds_params_method_set
    __swig_getmethods__["method"] = _Primme.primme_svds_params_method_get
    if _newclass:
        method = _swig_property(_Primme.primme_svds_params_method_get, _Primme.primme_svds_params_method_set)
    __swig_setmethods__["methodStage2"] = _Primme.primme_svds_params_methodStage2_set
    __swig_getmethods__["methodStage2"] = _Primme.primme_svds_params_methodStage2_get
    if _newclass:
        methodStage2 = _swig_property(_Primme.primme_svds_params_methodStage2_get, _Primme.primme_svds_params_methodStage2_set)
    __swig_setmethods__["intWorkSize"] = _Primme.primme_svds_params_intWorkSize_set
    __swig_getmethods__["intWorkSize"] = _Primme.primme_svds_params_intWorkSize_get
    if _newclass:
        intWorkSize = _swig_property(_Primme.primme_svds_params_intWorkSize_get, _Primme.primme_svds_params_intWorkSize_set)
    __swig_setmethods__["realWorkSize"] = _Primme.primme_svds_params_realWorkSize_set
    __swig_getmethods__["realWorkSize"] = _Primme.primme_svds_params_realWorkSize_get
    if _newclass:
        realWorkSize = _swig_property(_Primme.primme_svds_params_realWorkSize_get, _Primme.primme_svds_params_realWorkSize_set)
    __swig_setmethods__["locking"] = _Primme.primme_svds_params_locking_set
    __swig_getmethods__["locking"] = _Primme.primme_svds_params_locking_get
    if _newclass:
        locking = _swig_property(_Primme.primme_svds_params_locking_get, _Primme.primme_svds_params_locking_set)
    __swig_setmethods__["numOrthoConst"] = _Primme.primme_svds_params_numOrthoConst_set
    __swig_getmethods__["numOrthoConst"] = _Primme.primme_svds_params_numOrthoConst_get
    if _newclass:
        numOrthoConst = _swig_property(_Primme.primme_svds_params_numOrthoConst_get, _Primme.primme_svds_params_numOrthoConst_set)
    __swig_setmethods__["aNorm"] = _Primme.primme_svds_params_aNorm_set
    __swig_getmethods__["aNorm"] = _Primme.primme_svds_params_aNorm_get
    if _newclass:
        aNorm = _swig_property(_Primme.primme_svds_params_aNorm_get, _Primme.primme_svds_params_aNorm_set)
    __swig_setmethods__["eps"] = _Primme.primme_svds_params_eps_set
    __swig_getmethods__["eps"] = _Primme.primme_svds_params_eps_get
    if _newclass:
        eps = _swig_property(_Primme.primme_svds_params_eps_get, _Primme.primme_svds_params_eps_set)
    __swig_setmethods__["precondition"] = _Primme.primme_svds_params_precondition_set
    __swig_getmethods__["precondition"] = _Primme.primme_svds_params_precondition_get
    if _newclass:
        precondition = _swig_property(_Primme.primme_svds_params_precondition_get, _Primme.primme_svds_params_precondition_set)
    __swig_setmethods__["initSize"] = _Primme.primme_svds_params_initSize_set
    __swig_getmethods__["initSize"] = _Primme.primme_svds_params_initSize_get
    if _newclass:
        initSize = _swig_property(_Primme.primme_svds_params_initSize_get, _Primme.primme_svds_params_initSize_set)
    __swig_setmethods__["maxBasisSize"] = _Primme.primme_svds_params_maxBasisSize_set
    __swig_getmethods__["maxBasisSize"] = _Primme.primme_svds_params_maxBasisSize_get
    if _newclass:
        maxBasisSize = _swig_property(_Primme.primme_svds_params_maxBasisSize_get, _Primme.primme_svds_params_maxBasisSize_set)
    __swig_setmethods__["maxBlockSize"] = _Primme.primme_svds_params_maxBlockSize_set
    __swig_getmethods__["maxBlockSize"] = _Primme.primme_svds_params_maxBlockSize_get
    if _newclass:
        maxBlockSize = _swig_property(_Primme.primme_svds_params_maxBlockSize_get, _Primme.primme_svds_params_maxBlockSize_set)
    __swig_setmethods__["maxMatvecs"] = _Primme.primme_svds_params_maxMatvecs_set
    __swig_getmethods__["maxMatvecs"] = _Primme.primme_svds_params_maxMatvecs_get
    if _newclass:
        maxMatvecs = _swig_property(_Primme.primme_svds_params_maxMatvecs_get, _Primme.primme_svds_params_maxMatvecs_set)
    __swig_setmethods__["iseed"] = _Primme.primme_svds_params_iseed_set
    __swig_getmethods__["iseed"] = _Primme.primme_svds_params_iseed_get
    if _newclass:
        iseed = _swig_property(_Primme.primme_svds_params_iseed_get, _Primme.primme_svds_params_iseed_set)
    __swig_setmethods__["printLevel"] = _Primme.primme_svds_params_printLevel_set
    __swig_getmethods__["printLevel"] = _Primme.primme_svds_params_printLevel_get
    if _newclass:
        printLevel = _swig_property(_Primme.primme_svds_params_printLevel_get, _Primme.primme_svds_params_printLevel_set)
    __swig_setmethods__["stats"] = _Primme.primme_svds_params_stats_set
    __swig_getmethods__["stats"] = _Primme.primme_svds_params_stats_get
    if _newclass:
        stats = _swig_property(_Primme.primme_svds_params_stats_get, _Primme.primme_svds_params_stats_set)

    def __init__(self):
        this = _Primme.new_primme_svds_params()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_primme_svds_params
    __del__ = lambda self: None
primme_svds_params_swigregister = _Primme.primme_svds_params_swigregister
primme_svds_params_swigregister(primme_svds_params)

PRIMME_SVDS_primme = _Primme.PRIMME_SVDS_primme
PRIMME_SVDS_primmeStage2 = _Primme.PRIMME_SVDS_primmeStage2
PRIMME_SVDS_m = _Primme.PRIMME_SVDS_m
PRIMME_SVDS_n = _Primme.PRIMME_SVDS_n
PRIMME_SVDS_matrixMatvec = _Primme.PRIMME_SVDS_matrixMatvec
PRIMME_SVDS_applyPreconditioner = _Primme.PRIMME_SVDS_applyPreconditioner
PRIMME_SVDS_numProcs = _Primme.PRIMME_SVDS_numProcs
PRIMME_SVDS_procID = _Primme.PRIMME_SVDS_procID
PRIMME_SVDS_mLocal = _Primme.PRIMME_SVDS_mLocal
PRIMME_SVDS_nLocal = _Primme.PRIMME_SVDS_nLocal
PRIMME_SVDS_commInfo = _Primme.PRIMME_SVDS_commInfo
PRIMME_SVDS_globalSumReal = _Primme.PRIMME_SVDS_globalSumReal
PRIMME_SVDS_numSvals = _Primme.PRIMME_SVDS_numSvals
PRIMME_SVDS_target = _Primme.PRIMME_SVDS_target
PRIMME_SVDS_numTargetShifts = _Primme.PRIMME_SVDS_numTargetShifts
PRIMME_SVDS_targetShifts = _Primme.PRIMME_SVDS_targetShifts
PRIMME_SVDS_method = _Primme.PRIMME_SVDS_method
PRIMME_SVDS_methodStage2 = _Primme.PRIMME_SVDS_methodStage2
PRIMME_SVDS_intWorkSize = _Primme.PRIMME_SVDS_intWorkSize
PRIMME_SVDS_realWorkSize = _Primme.PRIMME_SVDS_realWorkSize
PRIMME_SVDS_intWork = _Primme.PRIMME_SVDS_intWork
PRIMME_SVDS_realWork = _Primme.PRIMME_SVDS_realWork
PRIMME_SVDS_matrix = _Primme.PRIMME_SVDS_matrix
PRIMME_SVDS_preconditioner = _Primme.PRIMME_SVDS_preconditioner
PRIMME_SVDS_locking = _Primme.PRIMME_SVDS_locking
PRIMME_SVDS_numOrthoConst = _Primme.PRIMME_SVDS_numOrthoConst
PRIMME_SVDS_aNorm = _Primme.PRIMME_SVDS_aNorm
PRIMME_SVDS_eps = _Primme.PRIMME_SVDS_eps
PRIMME_SVDS_precondition = _Primme.PRIMME_SVDS_precondition
PRIMME_SVDS_initSize = _Primme.PRIMME_SVDS_initSize
PRIMME_SVDS_maxBasisSize = _Primme.PRIMME_SVDS_maxBasisSize
PRIMME_SVDS_maxBlockSize = _Primme.PRIMME_SVDS_maxBlockSize
PRIMME_SVDS_maxMatvecs = _Primme.PRIMME_SVDS_maxMatvecs
PRIMME_SVDS_iseed = _Primme.PRIMME_SVDS_iseed
PRIMME_SVDS_printLevel = _Primme.PRIMME_SVDS_printLevel
PRIMME_SVDS_outputFile = _Primme.PRIMME_SVDS_outputFile
PRIMME_SVDS_stats_numOuterIterations = _Primme.PRIMME_SVDS_stats_numOuterIterations
PRIMME_SVDS_stats_numRestarts = _Primme.PRIMME_SVDS_stats_numRestarts
PRIMME_SVDS_stats_numMatvecs = _Primme.PRIMME_SVDS_stats_numMatvecs
PRIMME_SVDS_stats_numPreconds = _Primme.PRIMME_SVDS_stats_numPreconds
PRIMME_SVDS_stats_numGlobalSum = _Primme.PRIMME_SVDS_stats_numGlobalSum
PRIMME_SVDS_stats_volumeGlobalSum = _Primme.PRIMME_SVDS_stats_volumeGlobalSum
PRIMME_SVDS_stats_numOrthoInnerProds = _Primme.PRIMME_SVDS_stats_numOrthoInnerProds
PRIMME_SVDS_stats_elapsedTime = _Primme.PRIMME_SVDS_stats_elapsedTime
PRIMME_SVDS_stats_timeMatvec = _Primme.PRIMME_SVDS_stats_timeMatvec
PRIMME_SVDS_stats_timePrecond = _Primme.PRIMME_SVDS_stats_timePrecond
PRIMME_SVDS_stats_timeOrtho = _Primme.PRIMME_SVDS_stats_timeOrtho
PRIMME_SVDS_stats_timeGlobalSum = _Primme.PRIMME_SVDS_stats_timeGlobalSum
PRIMME_SVDS_monitorFun = _Primme.PRIMME_SVDS_monitorFun
PRIMME_SVDS_monitor = _Primme.PRIMME_SVDS_monitor

def sprimme_svds(*args):
    return _Primme.sprimme_svds(*args)
sprimme_svds = _Primme.sprimme_svds

def cprimme_svds(*args):
    return _Primme.cprimme_svds(*args)
cprimme_svds = _Primme.cprimme_svds

def dprimme_svds(*args):
    return _Primme.dprimme_svds(*args)
dprimme_svds = _Primme.dprimme_svds

def zprimme_svds(*args):
    return _Primme.zprimme_svds(*args)
zprimme_svds = _Primme.zprimme_svds

def primme_svds_get_member(primme_svds, label, value):
    return _Primme.primme_svds_get_member(primme_svds, label, value)
primme_svds_get_member = _Primme.primme_svds_get_member

def primme_svds_set_member(primme_svds, label, value):
    return _Primme.primme_svds_set_member(primme_svds, label, value)
primme_svds_set_member = _Primme.primme_svds_set_member

def primme_svds_member_info(label, label_name, type, arity):
    return _Primme.primme_svds_member_info(label, label_name, type, arity)
primme_svds_member_info = _Primme.primme_svds_member_info

def primme_svds_constant_info(label_name, value):
    return _Primme.primme_svds_constant_info(label_name, value)
primme_svds_constant_info = _Primme.primme_svds_constant_info
class PrimmeParams(primme_params):
    """
    Abstract class to specify the eigenvalue problem and the options for calling
    dprimme and zprimme.

    Example
    -------
    >>> import Primme, scipy.sparse, numpy as np
    >>> A = scipy.sparse.spdiags(range(100), [0], 100, 100) # sparse diag. matrix
    >>> class PP(Primme.PrimmeParams):
    ... 	def __init__(self):
    ... 		Primme.PrimmeParams.__init__(self)
    ... 	def matvec(self, X):
    ... 		return A*X
    >>> pp = PP()
    >>> pp.n = A.shape[0] # set problem dimension
    >>> pp.numEvals = 3   # set number of eigenvalues
    >>> pp.target = Primme.primme_largest # find the largest eigenvalues
    >>> pp.eps = 1e-6     # residual norm tolerance
    >>> evals = np.zeros(pp.numEvals)                    # store eigenvalues
    >>> evecs = np.zeros((pp.n, pp.numEvals), order='F') # store eigenvectors
    >>> norms = np.zeros(pp.numEvals)                    # store residual norms
    >>> ret = Primme.dprimme(evals, evecs, norms, pp) # call the solver
    >>> ret  # error code, 0 is success!
    0
    >>> pp.initSize # number of converged eigenpairs
    3
    >>> evals[0:pp.initSize] # converged values 
    array([ 99.,  98.,  97.])
    >>> # Time in seconds and A*v times that took
    >>> pp.stats.elapsedTime, pp.stats.numMatvecs # doctest: +SKIP
    0.5, 110

    """

    __swig_setmethods__ = {}
    for _s in [primme_params]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrimmeParams, name, value)
    __swig_getmethods__ = {}
    for _s in [primme_params]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PrimmeParams, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        Abstract class to specify the eigenvalue problem and the options for calling
        dprimme and zprimme.

        Example
        -------
        >>> import Primme, scipy.sparse, numpy as np
        >>> A = scipy.sparse.spdiags(range(100), [0], 100, 100) # sparse diag. matrix
        >>> class PP(Primme.PrimmeParams):
        ... 	def __init__(self):
        ... 		Primme.PrimmeParams.__init__(self)
        ... 	def matvec(self, X):
        ... 		return A*X
        >>> pp = PP()
        >>> pp.n = A.shape[0] # set problem dimension
        >>> pp.numEvals = 3   # set number of eigenvalues
        >>> pp.target = Primme.primme_largest # find the largest eigenvalues
        >>> pp.eps = 1e-6     # residual norm tolerance
        >>> evals = np.zeros(pp.numEvals)                    # store eigenvalues
        >>> evecs = np.zeros((pp.n, pp.numEvals), order='F') # store eigenvectors
        >>> norms = np.zeros(pp.numEvals)                    # store residual norms
        >>> ret = Primme.dprimme(evals, evecs, norms, pp) # call the solver
        >>> ret  # error code, 0 is success!
        0
        >>> pp.initSize # number of converged eigenpairs
        3
        >>> evals[0:pp.initSize] # converged values 
        array([ 99.,  98.,  97.])
        >>> # Time in seconds and A*v times that took
        >>> pp.stats.elapsedTime, pp.stats.numMatvecs # doctest: +SKIP
        0.5, 110

        """
        if self.__class__ == PrimmeParams:
            _self = None
        else:
            _self = self
        this = _Primme.new_PrimmeParams(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_PrimmeParams
    __del__ = lambda self: None

    def display(self):
        return _Primme.PrimmeParams_display(self)

    def set_method(self, method):
        return _Primme.PrimmeParams_set_method(self, method)

    def _set_targetShifts(self, targetShifts):
        return _Primme.PrimmeParams__set_targetShifts(self, targetShifts)

    def _get_targetShifts(self):
        return _Primme.PrimmeParams__get_targetShifts(self)

    def matvec(self, *args):
        return _Primme.PrimmeParams_matvec(self, *args)

    def prevec(self, *args):
        return _Primme.PrimmeParams_prevec(self, *args)

    def globalSum(self, *args):
        return _Primme.PrimmeParams_globalSum(self, *args)
    __swig_setmethods__["globalSum_set"] = _Primme.PrimmeParams_globalSum_set_set
    __swig_getmethods__["globalSum_set"] = _Primme.PrimmeParams_globalSum_set_get
    if _newclass:
        globalSum_set = _swig_property(_Primme.PrimmeParams_globalSum_set_get, _Primme.PrimmeParams_globalSum_set_set)

    def mon(self, *args):
        return _Primme.PrimmeParams_mon(self, *args)
    __swig_setmethods__["monitor_set"] = _Primme.PrimmeParams_monitor_set_set
    __swig_getmethods__["monitor_set"] = _Primme.PrimmeParams_monitor_set_get
    if _newclass:
        monitor_set = _swig_property(_Primme.PrimmeParams_monitor_set_get, _Primme.PrimmeParams_monitor_set_set)
    def __disown__(self):
        self.this.disown()
        _Primme.disown_PrimmeParams(self)
        return weakref_proxy(self)
PrimmeParams_swigregister = _Primme.PrimmeParams_swigregister
PrimmeParams_swigregister(PrimmeParams)

class PrimmeSvdsParams(primme_svds_params):
    """
    Abstract class to specify the eigenvalue problem and the options for calling
    dprimme_svds and zprimme_svds.

    Example
    -------
    >>> import Primme, scipy.sparse, numpy as np
    >>> A = scipy.sparse.spdiags(range(1,11), [0], 100, 10) # sparse diag. rect. matrix
    >>> class PSP(Primme.PrimmeSvdsParams):
    ... 	def __init__(self):
    ... 		Primme.PrimmeSvdsParams.__init__(self)
    ... 	def matvec(self, X, transpose):
    ... 		return A*X if transpose == 0 else A.H*X
    >>> pp = PSP()
    >>> pp.m, pp.n = A.shape # set problem dimensions
    >>> pp.numSvals = 3   # set number of singular values to seek
    >>> pp.target = Primme.primme_svds_smallest # find the smallest singular values
    >>> pp.eps = 1e-6     # residual norm tolerance
    >>> svals = np.zeros(pp.numSvals)                     # store singular values
    >>> svecsl = np.zeros((pp.m, pp.numSvals), order='F') # store left singular vectors
    >>> svecsr = np.zeros((pp.n, pp.numSvals), order='F') # store right singular vectors
    >>> norms = np.zeros(pp.numSvals)                     # store residual norms
    >>> ret = Primme.dprimme_svds(svals, svecsl, svecsr, norms, pp) # call the solver
    >>> ret  # error code, 0 is success!
    0
    >>> pp.initSize # number of converged singular pairs
    3
    >>> svals[0:pp.initSize] # converged singular values 
    array([ 1.,  2.,  3.])
    >>> # Time in seconds and A*v times that took
    >>> pp.stats.elapsedTime, pp.stats.numMatvecs # doctest: +SKIP
    0.7, 94

    """

    __swig_setmethods__ = {}
    for _s in [primme_svds_params]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrimmeSvdsParams, name, value)
    __swig_getmethods__ = {}
    for _s in [primme_svds_params]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PrimmeSvdsParams, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        Abstract class to specify the eigenvalue problem and the options for calling
        dprimme_svds and zprimme_svds.

        Example
        -------
        >>> import Primme, scipy.sparse, numpy as np
        >>> A = scipy.sparse.spdiags(range(1,11), [0], 100, 10) # sparse diag. rect. matrix
        >>> class PSP(Primme.PrimmeSvdsParams):
        ... 	def __init__(self):
        ... 		Primme.PrimmeSvdsParams.__init__(self)
        ... 	def matvec(self, X, transpose):
        ... 		return A*X if transpose == 0 else A.H*X
        >>> pp = PSP()
        >>> pp.m, pp.n = A.shape # set problem dimensions
        >>> pp.numSvals = 3   # set number of singular values to seek
        >>> pp.target = Primme.primme_svds_smallest # find the smallest singular values
        >>> pp.eps = 1e-6     # residual norm tolerance
        >>> svals = np.zeros(pp.numSvals)                     # store singular values
        >>> svecsl = np.zeros((pp.m, pp.numSvals), order='F') # store left singular vectors
        >>> svecsr = np.zeros((pp.n, pp.numSvals), order='F') # store right singular vectors
        >>> norms = np.zeros(pp.numSvals)                     # store residual norms
        >>> ret = Primme.dprimme_svds(svals, svecsl, svecsr, norms, pp) # call the solver
        >>> ret  # error code, 0 is success!
        0
        >>> pp.initSize # number of converged singular pairs
        3
        >>> svals[0:pp.initSize] # converged singular values 
        array([ 1.,  2.,  3.])
        >>> # Time in seconds and A*v times that took
        >>> pp.stats.elapsedTime, pp.stats.numMatvecs # doctest: +SKIP
        0.7, 94

        """
        if self.__class__ == PrimmeSvdsParams:
            _self = None
        else:
            _self = self
        this = _Primme.new_PrimmeSvdsParams(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_PrimmeSvdsParams
    __del__ = lambda self: None

    def display(self):
        return _Primme.PrimmeSvdsParams_display(self)

    def set_method(self, method, methodStage1, methodStage2):
        return _Primme.PrimmeSvdsParams_set_method(self, method, methodStage1, methodStage2)

    def _set_targetShifts(self, targetShifts):
        return _Primme.PrimmeSvdsParams__set_targetShifts(self, targetShifts)

    def _get_targetShifts(self):
        return _Primme.PrimmeSvdsParams__get_targetShifts(self)

    def matvec(self, *args):
        return _Primme.PrimmeSvdsParams_matvec(self, *args)

    def prevec(self, *args):
        return _Primme.PrimmeSvdsParams_prevec(self, *args)

    def globalSum(self, *args):
        return _Primme.PrimmeSvdsParams_globalSum(self, *args)
    __swig_setmethods__["globalSum_set"] = _Primme.PrimmeSvdsParams_globalSum_set_set
    __swig_getmethods__["globalSum_set"] = _Primme.PrimmeSvdsParams_globalSum_set_get
    if _newclass:
        globalSum_set = _swig_property(_Primme.PrimmeSvdsParams_globalSum_set_get, _Primme.PrimmeSvdsParams_globalSum_set_set)

    def mon(self, *args):
        return _Primme.PrimmeSvdsParams_mon(self, *args)
    __swig_setmethods__["monitor_set"] = _Primme.PrimmeSvdsParams_monitor_set_set
    __swig_getmethods__["monitor_set"] = _Primme.PrimmeSvdsParams_monitor_set_get
    if _newclass:
        monitor_set = _swig_property(_Primme.PrimmeSvdsParams_monitor_set_get, _Primme.PrimmeSvdsParams_monitor_set_set)
    def __disown__(self):
        self.this.disown()
        _Primme.disown_PrimmeSvdsParams(self)
        return weakref_proxy(self)
PrimmeSvdsParams_swigregister = _Primme.PrimmeSvdsParams_swigregister
PrimmeSvdsParams_swigregister(PrimmeSvdsParams)

import numpy as np
from scipy.sparse.linalg.interface import aslinearoperator

__docformat__ = "restructuredtext en"

_PRIMMEErrors = {
0: "success",
1: "reported only amount of required memory",
-1: "failed in allocating int or real workspace",
-2: "malloc failed in allocating a permutation integer array",
-3: "main_iter() encountered problem; the calling stack of the functions where the error occurred was printed in 'stderr'",
-4: "argument 'primme' is NULL",
-5: "'n' < 0 or 'nLocal' < 0 or 'nLocal' > 'n'",
-6: "'numProcs' < 1",
-7: "'matrixMatvec' is NULL",
-8: "'applyPreconditioner' is NULL and 'precondition' is not NULL",
-9: "'not used",
-10: "'numEvals' > 'n'",
-11: "'numEvals' < 0",
-12: "'eps' > 0 and 'eps' < machine precision",
-13: "'target' is not properly defined",
-14: "'target' is one of 'primme_largest_abs', 'primme_closest_geq', 'primme_closest_leq' or 'primme_closest_abs' but 'numTargetShifts' <= 0 (no shifts)",
-15: "'target' is one of 'primme_largest_abs', 'primme_closest_geq', 'primme_closest_leq' or 'primme_closest_abs' but 'targetShifts' is NULL  (no shifts array)",
-16: "'numOrthoConst' < 0 or 'numOrthoConst' > 'n'. (no free dimensions left)",
-17: "'maxBasisSize' < 2",
-18: "'minRestartSize' < 0 or 'minRestartSize' shouldn't be zero",
-19: "'maxBlockSize' < 0 or 'maxBlockSize' shouldn't be zero",
-20: "'maxPrevRetain' < 0",
-21: "'scheme' is not one of *primme_thick* or *primme_dtr*",
-22: "'initSize' < 0",
-23: "'locking' == 0 and 'initSize' > 'maxBasisSize'",
-24: "'locking' and 'initSize' > 'numEvals'",
-25: "'maxPrevRetain' + 'minRestartSize' >= 'maxBasisSize'",
-26: "'minRestartSize' >= 'n'",
-27: "'printLevel' < 0 or 'printLevel' > 5",
-28: "'convTest' is not one of 'primme_full_LTolerance', 'primme_decreasing_LTolerance', 'primme_adaptive_ETolerance' or 'primme_adaptive'",
-29: "'convTest' == 'primme_decreasing_LTolerance' and 'relTolBase' <= 1",
-30: "'evals' is NULL, but not 'evecs' and 'resNorms'",
-31: "'evecs' is NULL, but not 'evals' and 'resNorms'",
-32: "'resNorms' is NULL, but not 'evecs' and 'evals'",
-33: "'locking' == 0 and 'minRestartSize' < 'numEvals'",
-34: "'ldevecs' is less than 'nLocal'",
-35: "'ldOPs' is non-zero and less than 'nLocal'",
-36 : "not enough memory for realWork",
-37 : "not enough memory for intWork",
-38 : "'locking' == 0 and 'target' is 'primme_closest_leq' or 'primme_closet_geq'"
}

_PRIMMESvdsErrors = {
0   : "success",
1   : "reported only amount of required memory",
-1  : "failed in allocating int or real workspace",
-2  : "malloc failed in allocating a permutation integer array",
-3  : "main_iter() encountered problem; the calling stack of the functions where the error occurred was printed in 'stderr'",
-4  : "primme_svds is NULL",
-5  : "Wrong value for m or n or mLocal or nLocal",
-6  : "Wrong value for numProcs",
-7  : "matrixMatvec is not set",
-8  : "applyPreconditioner is not set but precondition == 1 ",
-9  : "numProcs >1 but globalSumDouble is not set",
-10 : "Wrong value for numSvals, it's larger than min(m, n)",
-11 : "Wrong value for numSvals, it's smaller than 1",
-13 : "Wrong value for target",
-14 : "Wrong value for method",
-15 : "Not supported combination of method and methodStage2",
-16 : "Wrong value for printLevel",
-17 : "svals is not set",
-18 : "svecs is not set",
-19 : "resNorms is not set",
-20 : "not enough memory for realWork",
-21 : "not enough memory for intWork"
}


class PrimmeError(RuntimeError):
    """
    PRIMME error
    """
    def __init__(self, err):
        self.err = err
        RuntimeError.__init__(self, "PRIMME error %d: %s" % (err, _PRIMMEErrors[err]))

class PrimmeSvdsError(RuntimeError):
    """
    PRIMME SVDS error
    """
    def __init__(self, err):
        self.err = err
        msg = ""
        if err >= -100:
            msg = _PRIMMESvdsErrors[err]
        elif err >= -200:
            msg = "Error from PRIMME first stage: " + _PRIMMEErrors[err+100]
        elif err >= -300:
            msg = "Error from PRIMME second stage: " + _PRIMMEErrors[err+200]
        RuntimeError.__init__(self, "PRIMME SVDS error %d: %s" % (err, msg))


def eigsh(A, k=6, M=None, sigma=None, which='LM', v0=None,
          ncv=None, maxiter=None, tol=0, return_eigenvectors=True,
          Minv=None, OPinv=None, mode='normal', ortho=None,
          return_stats=False, maxBlockSize=0, minRestartSize=0,
          maxPrevRetain=0, method=None, return_history=False, **kargs):
    """
    Find k eigenvalues and eigenvectors of the real symmetric square matrix
    or complex Hermitian matrix A.

    Solves ``A * x[i] = w[i] * x[i]``, the standard eigenvalue problem for
    w[i] eigenvalues with corresponding eigenvectors x[i].

    If M is specified, solves ``A * x[i] = w[i] * M * x[i]``, the
    generalized eigenvalue problem for w[i] eigenvalues
    with corresponding eigenvectors x[i]

    Parameters
    ----------
    A : An N x N matrix, array, sparse matrix, or LinearOperator
        the operation A * x, where A is a real symmetric matrix or complex
        Hermitian.
    k : int, optional
        The number of eigenvalues and eigenvectors to be computed. Must be
        1 <= k < min(A.shape).
    M : An N x N matrix, array, sparse matrix, or LinearOperator
        (not supported yet)
        the operation M * x for the generalized eigenvalue problem

            A * x = w * M * x.

        M must represent a real, symmetric matrix if A is real, and must
        represent a complex, Hermitian matrix if A is complex. For best
        results, the data type of M should be the same as that of A.
    sigma : real, optional
        Find eigenvalues near sigma.
    v0 : N x i, ndarray, optional
        Initial guesses to the eigenvectors.
    ncv : int, optional
        The maximum size of the basis
    which : str ['LM' | 'SM' | 'LA' | 'SA']
        Which `k` eigenvectors and eigenvalues to find:

            'LM' : Largest in magnitude eigenvalues; the farthest from sigma

            'SM' : Smallest in magnitude eigenvalues; the closest to sigma

            'LA' : Largest algebraic eigenvalues

            'SA' : Smallest algebraic eigenvalues

            'CLT' : closest but left to sigma

            'CGT' : closest but greater than sigma

        When sigma == None, 'LM', 'SM', 'CLT', and 'CGT' treat sigma as zero. 
    maxiter : int, optional
        Maximum number of iterations.
    tol : float
        Required accuracy for eigenpairs (stopping criterion).
        The default value is sqrt of machine precision.
    Minv : (not supported yet)
        The inverse of M in the generalized eigenproblem.
    OPinv : N x N matrix, array, sparse matrix, or LinearOperator, optional
        Preconditioner to accelerate the convergence. Usually it is an
        approximation of the inverse of (A - sigma*M).
    return_eigenvectors : bool, optional
        Return eigenvectors (True) in addition to eigenvalues
    mode : string ['normal' | 'buckling' | 'cayley']
        Only 'normal' mode is supported.
    ortho : N x i, ndarray, optional
        Seek the eigenvectors orthogonal to these ones. The provided
        vectors *should* be orthonormal. Useful to avoid converging to previously
        computed solutions.
    maxBlockSize : int, optional
        Maximum number of vectors added at every iteration.
    minRestartSize : int, optional
        Number of approximate eigenvectors kept during restart.
    maxPrevRetain: int, optional
        Number of approximate eigenvectors kept from previous iteration in
        restart. Also referred as +k vectors in GD+k.
    method : int, optional
        Preset method, one of:

        - DEFAULT_MIN_TIME : a variant of JDQMR,
        - DEFAULT_MIN_MATVECS : GD+k
        - DYNAMIC : choose dynamically between these previous methods.

        See a detailed description of the methods and other possible values
        in [2]_.

    return_stats : bool, optional
        If True, the function returns extra information (see stats in Returns).
    return_history: bool, optional
        If True, the function returns performance information at every iteration
        (see hist in Returns).

    Returns
    -------
    w : array
        Array of k eigenvalues ordered to best satisfy "which".
    v : array
        An array representing the `k` eigenvectors.  The column ``v[:, i]`` is
        the eigenvector corresponding to the eigenvalue ``w[i]``.
    stats : dict, optional (if return_stats)
        Extra information reported by PRIMME:

        - "numOuterIterations": number of outer iterations
        - "numRestarts": number of restarts
        - "numMatvecs": number of A*v
        - "numPreconds": number of OPinv*v
        - "elapsedTime": time that took 
        - "estimateMinEVal": the leftmost Ritz value seen
        - "estimateMaxEVal": the rightmost Ritz value seen
        - "estimateLargestSVal": the largest singular value seen
        - "rnorms" : ||A*x[i] - x[i]*w[i]||
        - "hist" : (if return_history) report at every outer iteration of:

          - "elapsedTime": time spent up to now
          - "numMatvecs": number of A*v spent up to now
          - "nconv": number of converged pair
          - "eval": eigenvalue of the first unconverged pair
          - "resNorm": residual norm of the first unconverged pair

    Raises
    ------
    PrimmeError
        When the requested convergence is not obtained.

        The PRIMME error code can be found as ``err`` attribute of the exception
        object.

    See Also
    --------
    scipy.sparse.linalg.eigs : eigenvalues and eigenvectors for a general (nonsymmetric) matrix A
    Primme.svds : singular value decomposition for a matrix A

    Notes
    -----
    This function is a wrapper to PRIMME functions to find the eigenvalues and
    eigenvectors [1]_.

    References
    ----------
    .. [1] PRIMME Software, https://github.com/primme/primme
    .. [2] Preset Methods, http://www.cs.wm.edu/~andreas/software/doc/readme.html#preset-methods
    .. [3] A. Stathopoulos and J. R. McCombs PRIMME: PReconditioned
           Iterative MultiMethod Eigensolver: Methods and software
           description, ACM Transaction on Mathematical Software Vol. 37,
           No. 2, (2010), 21:1-21:30.

    Examples
    --------
    >>> import Primme, scipy.sparse
    >>> A = scipy.sparse.spdiags(range(100), [0], 100, 100) # sparse diag. matrix
    >>> evals, evecs = Primme.eigsh(A, 3, tol=1e-6, which='LA')
    >>> evals # the three largest eigenvalues of A
    array([ 99.,  98.,  97.])
    >>> new_evals, new_evecs = Primme.eigsh(A, 3, tol=1e-6, which='LA', ortho=evecs)
    >>> new_evals # the next three largest eigenvalues
    array([ 96.,  95.,  94.])
    """

    A = aslinearoperator(A)
    if len(A.shape) != 2 or A.shape[0] != A.shape[1]:
        raise ValueError('A: expected square matrix (shape=%s)' % (A.shape,))

    if M is not None:
        raise ValueError('generalized problems (M != None) are not supported')

    hist = {"numMatvecs": [], "elapsedTime": [], "nconv": [],
            "eval": [], "resNorm": []}

    class PP(PrimmeParams):
        def __init__(self):
            PrimmeParams.__init__(self)
        def matvec(self, X):
            return A.matmat(X)
        def prevec(self, X):
            return OPinv.matmat(X)
        def mon(self, basisEvals, basisFlags, iblock, basisNorms, numConverged,
                    lockedEvals, lockedFlags, lockedNorms, inner_its, LSRes, event):
            if event == 0 and len(iblock)>0: # event iteration
                hist["numMatvecs"].append(self.stats.numMatvecs)
                hist["elapsedTime"].append(self.stats.elapsedTime)
                hist["nconv"].append(numConverged)
                hist["eval"].append(basisEvals[iblock[0]])
                hist["resNorm"].append(basisNorms[iblock[0]])

    pp = PP()

    pp.n = A.shape[0]

    if k <= 0 or k > pp.n:
        raise ValueError("k=%d must be between 1 and %d, the order of the "
                         "square input matrix." % (k, pp.n))
    pp.numEvals = k
    pp.correctionParams.precondition = 0 if OPinv is None else 1

    if which == 'LM':
        pp.target = primme_largest_abs
        if sigma is None:
            sigma = 0.0
    elif which == 'LA':
        pp.target = primme_largest
        sigma = None
    elif which == 'SA':
        pp.target = primme_smallest
        sigma = None
    elif which == 'SM':
        pp.target = primme_closest_abs
        if sigma is None:
            sigma = 0.0
    elif which == 'CLT':
        pp.target = primme_closest_leq
        if sigma is None:
            sigma = 0.0
    elif which == 'CGT':
        pp.target = primme_closest_geq
        if sigma is None:
            sigma = 0.0
    else:
        raise ValueError("which='%s' not supported" % which)

    if sigma is not None:
        pp.targetShifts = np.array([sigma], dtype=np.dtype('d'))

    pp.eps = tol

    if ncv is not None:
        pp.maxBasisSize = ncv

    if maxiter is not None:
        pp.maxMatvecs = maxiter

    if OPinv is not None:
        OPinv = aslinearoperator(OPinv)
        if OPinv.shape[0] != OPinv.shape[1] or OPinv.shape[0] != A.shape[0]:
            raise ValueError('OPinv: expected square matrix with same shape as A (shape=%s)' % (OPinv.shape,))
        pp.correctionParams.precondition = 1

    if ortho is not None:
        if ortho.shape[0] != pp.n:
            raise ValueError('ortho: expected matrix with the same columns as A (shape=%s)' % (ortho.shape,))
        pp.numOrthoConst = min(ortho.shape[1], pp.n)

    if return_history and return_stats:
        pp.monitor_set = 1

# Set other parameters
    for dk, dv in kargs.items():
      setattr(pp, dk, dv)

    if A.dtype.kind in frozenset(["b", "i", "u"]) or A.dtype.type is np.double:
        dtype = np.dtype("d")
    else:
        dtype = A.dtype

    if dtype.type is np.complex64:
        Xprimme = cprimme
        rtype = np.dtype(np.float32)
    elif dtype.type is np.float32:
        Xprimme = sprimme
        rtype = np.dtype(np.float32)
    elif dtype.type is np.float64:
        Xprimme = dprimme
        rtype = np.dtype(np.float64)
    else:
        Xprimme = zprimme
        rtype = np.dtype(np.float64)

    evals = np.zeros(pp.numEvals, rtype)
    norms = np.zeros(pp.numEvals, rtype)
    evecs = np.zeros((pp.n, pp.numOrthoConst+pp.numEvals), dtype, order='F')

    if ortho is not None:
        np.copyto(evecs[:, 0:pp.numOrthoConst], ortho[:, 0:pp.numOrthoConst])

    if v0 is not None:
        pp.initSize = min(v0.shape[1], pp.numEvals)
        np.copyto(evecs[:, pp.numOrthoConst:pp.numOrthoConst+pp.initSize],
            v0[:, 0:pp.initSize])

    if maxBlockSize:
        pp.maxBlockSize = maxBlockSize

    if minRestartSize:
        pp.minRestartSize = minRestartSize

    if maxPrevRetain:
        pp.restartingParams.maxPrevRetain = maxPrevRetain

    if method is not None:
        pp.set_method(method)

    err = Xprimme(evals, evecs, norms, pp)

    if err != 0:
        raise PrimmeError(err)

    evals = evals[0:pp.initSize]
    norms = norms[0:pp.initSize]
    evecs = evecs[:, pp.numOrthoConst:pp.numOrthoConst+pp.initSize]

    if return_stats:
        stats = dict((f, getattr(pp.stats, f)) for f in [
            "numOuterIterations", "numRestarts", "numMatvecs",
            "numPreconds", "elapsedTime", "estimateMinEVal",
            "estimateMaxEVal", "estimateLargestSVal"])
        stats['rnorms'] = norms
        if return_history:
            stats["hist"] = hist
        return evals, evecs, stats
    else:
        return evals, evecs


def svds(A, k=6, ncv=None, tol=0, which='LM', v0=None,
         maxiter=None, return_singular_vectors=True,
         precAHA=None, precAAH=None, precAug=None,
         u0=None, orthou0=None, orthov0=None,
         return_stats=False, maxBlockSize=0,
         method=None, methodStage1=None, methodStage2=None,
         return_history=False, **kargs):
    """
    Compute k singular values and vectors of the matrix A.

    Parameters
    ----------
    A : {sparse matrix, LinearOperator}
        Array to compute the SVD on, of shape (M, N)
    k : int, optional
        Number of singular values and vectors to compute.
        Must be 1 <= k < min(A.shape).
    ncv : int, optional
        The maximum size of the basis
    tol : float, optional
        Tolerance for singular values. Zero (default) means 10**4 times the machine precision.

        A triplet ``(u,sigma,v)`` is marked as converged when
        (||A*v - sigma*u||**2 + ||A.H*u - sigma*v||**2)**.5
        is less than "tol" * ||A||, or close to the minimum tolerance that
        the method can achieve. See the note.
    which : str ['LM' | 'SM'] or number, optional
        Which `k` singular values to find:

            - 'LM' : largest singular values
            - 'SM' : smallest singular values
            - number : closest singular values to (referred as sigma later)

    u0 : ndarray, optional
        Initial guesses for the left singular vectors.

        If only u0 or v0 is provided, the other is computed. If both are
        provided, u0 and v0 should have the same number of columns.
    v0 : ndarray, optional
        Initial guesses for the right singular vectors.
    maxiter : int, optional
        Maximum number of matvecs with A and A.H. 
    precAHA : {N x N matrix, array, sparse matrix, LinearOperator}, optional
        Approximate inverse of (A.H*A - sigma**2*I). If provided and M>=N, it
        usually accelerates the convergence.
    precAAH : {M x M matrix, array, sparse matrix, LinearOperator}, optional
        Approximate inverse of (A*A.H - sigma**2*I). If provided and M<N, it
        usually accelerates the convergence.
    precAug : {(M+N) x (M+N) matrix, array, sparse matrix, LinearOperator}, optional
        Approximate inverse of ([zeros() A.H; zeros() A] - sigma*I).
    orthou0 : ndarray, optional
        Left orthogonal vector constrain.

        Seek singular triplets orthogonal to orthou0 and orthov0. The provided vectors
        *should* be orthonormal. If only orthou0 or orthov0 is provided, the other
        is computed. Useful to avoid converging to previously computed solutions.
    orthov0 : ndarray, optional
        Right orthogonal vector constrain. See orthou0.
    maxBlockSize : int, optional
        Maximum number of vectors added at every iteration.
    return_stats : bool, optional
        If True, the function returns extra information (see stats in Returns).
    return_history: bool, optional
        If True, the function returns performance information at every iteration

    Returns
    -------
    u : ndarray, shape=(M, k), optional
        Unitary matrix having left singular vectors as columns.
        Returned if `return_singular_vectors` is True.
    s : ndarray, shape=(k,)
        The singular values.
    vt : ndarray, shape=(k, N), optional
        Unitary matrix having right singular vectors as rows.
        Returned if `return_singular_vectors` is True.
    stats : dict, optional (if return_stats)
        Extra information reported by PRIMME:

        - "numOuterIterations": number of outer iterations
        - "numRestarts": number of restarts
        - "numMatvecs": number of matvecs with A and A.H
        - "numPreconds": cumulative number of applications of precAHA, precAAH
          and precAug
        - "elapsedTime": time that took 
        - "rnorms" : (||A*v[:,i] - sigma[i]*u[:,i]||**2 + ||A.H*u[:,i] - sigma[i]*v[:,i]||**2)**.5
        - "hist" : (if return_history) report at every outer iteration of:

          - "elapsedTime": time spent up to now
          - "numMatvecs": number of A*v and A.H*v spent up to now
          - "nconv": number of converged triplets
          - "sval": singular value of the first unconverged triplet
          - "resNorm": residual norm of the first unconverged triplet

    Notes
    -----
    The default method used is the hybrid method, which first solves the
    equivalent eigenvalue problem A.H*A or A*A.H (normal equations) and then
    refines the solution solving the augmented problem. The minimum tolerance
    that this method can achieve is ||A||*epsilon, where epsilon is the
    machine precision. However it may not return triplets with singular values
    smaller than ||A||*epsilon if "tol" is smaller than ||A||*epsilon/sigma.

    This function is a wrapper to PRIMME functions to find singular values and
    vectors [1]_.

    References
    ----------
    .. [1] PRIMME Software, https://github.com/primme/primme

    .. [2] L. Wu, E. Romero and A. Stathopoulos, PRIMME_SVDS: A High-
           Performance Preconditioned SVD Solver for Accurate Large-Scale
           Computations. https://arxiv.org/abs/1607.01404

    See Also
    --------
    Primme.eigsh : eigenvalue decomposition for a sparse symmetrix/complex Hermitian matrix A
    scipy.sparse.linalg.eigs : eigenvalues and eigenvectors for a general (nonsymmetric) matrix A

    Examples
    --------
    >>> import Primme, scipy.sparse
    >>> A = scipy.sparse.spdiags(range(1, 11), [0], 100, 10) # sparse diag. rect. matrix
    >>> svecs_left, svals, svecs_right = Primme.svds(A, 3, tol=1e-6, which='SM')
    >>> svals # the three smallest singular values of A
    array([ 1.,  2.,  3.])

    >>> import Primme, scipy.sparse
    >>> A = scipy.sparse.rand(10000, 100, random_state=10)
    >>> prec = scipy.sparse.spdiags(np.reciprocal(A.multiply(A).sum(axis=0)),
    ...           [0], 100, 100) # square diag. preconditioner
    >>> svecs_left, svals, svecs_right = Primme.svds(A, 3, which=6.0, tol=1e-6, precAHA=prec)
    >>> ["%.5f" % x for x in svals.flat] # the three closest singular values of A to 0.5
    ['5.99871', '5.99057', '6.01065']
    """

    A = aslinearoperator(A)

    m, n = A.shape

    if k <= 0 or k > min(n, m):
        raise ValueError("k=%d must be between 1 and min(A.shape)=%d" % (k, min(n, m)))

    if precAHA is not None:
        precAHA = aslinearoperator(precAHA)
        if precAHA.shape[0] != precAHA.shape[1] or precAHA.shape[0] != n:
            raise ValueError('precAHA: expected square matrix with size %d' % n)

    if precAAH is not None:
        precAAH = aslinearoperator(precAAH)
        if precAAH.shape[0] != precAAH.shape[1] or precAAH.shape[0] != m:
            raise ValueError('precAAH: expected square matrix with size %d' % m)

    if precAug is not None:
        precAug = aslinearoperator(precAug)
        if precAug.shape[0] != precAug.shape[1] or precAug.shape[0] != m+n:
            raise ValueError('precAug: expected square matrix with size %d' % (m+n))

    hist = {"numMatvecs": [], "elapsedTime": [], "nconv": [],
            "sval": [], "resNorm": []}

    class PSP(PrimmeSvdsParams):
        def __init__(self):
            PrimmeSvdsParams.__init__(self)

        def matvec(self, X, transpose):
            if transpose == 0:
                return A.matmat(X)
            else:
                return A.H.matmat(X) 

        def prevec(self, X, mode):
            if mode == primme_svds_op_AtA and precAHA is not None:
                return precAHA.matmat(X)
            elif mode == primme_svds_op_AAt and precAAH is not None:
                return precAAH.matmat(X) 
            elif mode == primme_svds_op_augmented and precAug is not None:
                return precAug.matmat(X) 
            return X

        def mon(self, basisSvals, basisFlags, iblock, basisNorms, numConverged,
                    lockedSvals, lockedFlags, lockedNorms, inner_its, LSRes,
                    event, stage):
            if event == 0 and len(iblock)>0: # event iteration
                hist["numMatvecs"].append(self.stats.numMatvecs)
                hist["elapsedTime"].append(self.stats.elapsedTime)
                hist["nconv"].append(numConverged)
                hist["sval"].append(basisSvals[iblock[0]])
                hist["resNorm"].append(basisNorms[iblock[0]])

    pp = PSP()

    pp.m = A.shape[0]
    pp.n = A.shape[1]

    pp.numSvals = k

    if which == 'LM':
        pp.target = primme_svds_largest
    elif which == 'SM':
        pp.target = primme_svds_smallest
    else:
        try:
            which = float(which)
        except:
            raise ValueError("which must be either 'LM', 'SM' or a number.")
        pp.target = primme_svds_closest_abs
        pp.targetShifts = np.array([which], dtype='d')

    pp.eps = tol

    if ncv:
        pp.maxBasisSize = ncv

    if maxiter:
# NOTE: every eigensolver iteration spend two matvecs*blockSize
        pp.maxMatvecs = maxiter*(maxBlockSize if maxBlockSize else 1)/2

    if maxBlockSize:
        pp.maxBlockSize = maxBlockSize

    if precAHA is not None or precAAH is not None or precAug is not None:
        pp.precondition = 1

    def check_pair(u, v, var_names):
        if ((u is not None and u.shape[0] != m) or
                (v is not None and v.shape[0] != n)):
            aux = v; v = u; u = aux

        if ((u is not None and u.shape[0] != m) or
                (v is not None and v.shape[0] != n)):
            aux = v; v = u; u = aux
            raise ValueError("%s don't have the expected number of rows." % var_names)

        if u is not None and v is not None and u.shape[1] != v.shape[1]:
            raise ValueError("%s don't have the same number of columns." % var_names)

        if u is not None and v is None:
            v, _ = np.linalg.qr(A.H.matmult(u))

        if v is not None and u is None:
            u, _ = np.linalg.qr(A.matmult(v))

        return u, v

    orthou0, orthov0 = check_pair(orthou0, orthov0, "orthov0 or orthou0")

    if orthou0 is not None:
        pp.numOrthoConst = min(orthou0.shape[1], min(m,n))

    if return_history and return_stats:
        pp.monitor_set = 1

# Set other parameters
    for dk, dv in kargs.items():
      setattr(pp, dk, dv)

    if A.dtype.kind in frozenset(["b", "i", "u"]) or A.dtype.type is np.double:
        dtype = np.dtype("d")
    else:
        dtype = A.dtype

    if dtype.type is np.complex64:
        Xprimme_svds = cprimme_svds
        rtype = np.dtype(np.float32)
    elif dtype.type is np.float32:
        Xprimme_svds = sprimme_svds
        rtype = np.dtype(np.float32)
    elif dtype.type is np.float64:
        Xprimme_svds = dprimme_svds
        rtype = np.dtype(np.float64)
    else:
        Xprimme_svds = zprimme_svds
        rtype = np.dtype(np.float64)

    svals = np.zeros(pp.numSvals, rtype)
    svecsl = np.zeros((pp.m, pp.numOrthoConst+pp.numSvals), dtype, order='F')
    svecsr = np.zeros((pp.n, pp.numOrthoConst+pp.numSvals), dtype, order='F')
    norms = np.zeros(pp.numSvals, rtype)

    if orthou0 is not None:
        np.copyto(svecsl[:, 0:pp.numOrthoConst], orthou0[:, 0:pp.numOrthoConst])
        np.copyto(svecsr[:, 0:pp.numOrthoConst], orthov0[:, 0:pp.numOrthoConst])

    u0, v0 = check_pair(u0, v0, "v0 or u0")

    if v0 is not None:
        pp.initSize = min(v0.shape[1], pp.numSvals)
        np.copyto(svecsl[:, pp.numOrthoConst:pp.numOrthoConst+pp.initSize], u0[:, 0:pp.initSize])
        np.copyto(svecsr[:, pp.numOrthoConst:pp.numOrthoConst+pp.initSize], v0[:, 0:pp.initSize])

# Set method
    if method is not None or methodStage1 is not None or methodStage2 is not None:
        if method is None: method = primme_svds_default
        if methodStage1 is None: methodStage1 = PRIMME_DEFAULT_METHOD
        if methodStage2 is None: methodStage2 = PRIMME_DEFAULT_METHOD
        pp.set_method(method, methodStage1, methodStage2)

    err = Xprimme_svds(svals, svecsl, svecsr, norms, pp)

    if err != 0:
        raise PrimmeSvdsError(err)

    if return_stats:
        stats = dict((f, getattr(pp.stats, f)) for f in [
            "numOuterIterations", "numRestarts", "numMatvecs",
            "numPreconds", "elapsedTime"])
        stats["rnorms"] = norms
        if return_history:
            stats["hist"] = hist

    if not return_singular_vectors:
        return svals if not return_stats else (svals, stats)

    svals = svals[0:pp.initSize]
    norms = norms[0:pp.initSize]
    svecsl = svecsl[:, pp.numOrthoConst:pp.numOrthoConst+pp.initSize]
    svecsr = svecsr[:, pp.numOrthoConst:pp.numOrthoConst+pp.initSize]

# Transpose conjugate svecsr
    svecsr = svecsr.T.conj()

    if not return_stats:
        return svecsl, svals, svecsr
    else:
        return svecsl, svals, svecsr, stats


PrimmeParams.targetShifts = property(PrimmeParams._get_targetShifts, PrimmeParams._set_targetShifts)
PrimmeSvdsParams.targetShifts = property(PrimmeSvdsParams._get_targetShifts, PrimmeSvdsParams._set_targetShifts)

# This file is compatible with both classic and new-style classes.


